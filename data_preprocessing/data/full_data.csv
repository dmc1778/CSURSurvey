,BibliographyID,Language,Addressed problem,Publication,Problem concise,rq1_data_broad_source,rq1_project_name,rq1_repository_name,rq1_benchmark_name,Granularity,rq1_broad_type,rq1_sub_type,L1_repr,L2_repr,rq2_embedding,rq2_embedding_broad_cat,Vulnerability types (RQ4),Tools,broad_category,model_family,RQ3,Detection granularity (RQ5),Interpretable (RQ7),Abstract,,Further explanation
,chen2020machine,Java,"Previous approach uses manually-labeled data from the curated database for training new models, however, in this way, a large amount of data remains unused. This unused set includes data items that fail our initial keyword-based filtering, and data items that are predicted as not related to vulnerability by the current production models.",A machine learning approach for vulnerability curation,Training data problem,Hybrid,N.A,"Jira, Bugzilla, GitHub, CVE",NVD,"Issue, pr, commits, reports, emails, CVE",Hybrid,Hybrid,Hybrid,Token+Commit Metrics,Word2vec,Hybrid,N.A,scikit-learn,ML,N.A,"Random Forest, Naive Bayes, KNN, SVM, Gradient Boosting, AdaBoost",Binary,No,"Software composition analysis depends on database of open-source library vulerabilities, curated by security researchers using various sources, such as bug tracking systems, commits, and mailing lists. We report the design and implementation of a machine learning system to help the curation by by automatically predicting the vulnerability-relatedness of each data item. It supports a complete pipeline from data collection, model training and prediction, to the validation of new models before deployment. It is executed iteratively to generate better models as new input data become available. We use self-training to significantly and automatically increase the size of the training dataset, opportunistically maximizing the improvement in the models' quality at each iteration. We devised new deployment stability metric to evaluate the quality of the new models before deployment into production, which helped to discover an error. We experimentally evaluate the improvement in the performance of the models in one iteration, with 27.59% maximum PR AUC improvements. Ours is the first of such study across a variety of data sources. We discover that the addition of the features of the corresponding commits to the features of issues/pull requests improve the precision for the recall values that matter. We demonstrate the effectiveness of self-training alone, with 10.50% PR AUC improvement, and we discover that there is no uniform ordering of word2vec parameters sensitivity across data sources.",,https://docs.google.com/document/d/1oQiqsIvUdt79WnrWGKBaVu-xesQntzq3txVggRblQDM/edit?usp=sharing
,zhou2017automated,*,"Firstly, these tools can only support one or two specific languages and certain patterns of vulnerabilities well. For example, the static analysis tool FlawFinder [19] is limited to sending buffer overflow risks, race conditions, and potential shell meta-character usage in C/C++. Moreover, most of these approaches operate on an entire software project and deliver long lists of potentially unsafe code with extremely high false positive rates ",Automated identification of security issues from commit messages and reports,High false positive of static analyzers,Repository,N.A,"GitHub, Jira, Bugzilla",N.A,"commits, bug reports",text,text,Token,N.A,Word2vec,Token vector embedding,N.A,N.A,ML,N.A,"SVM, Logistic Regression, Random Forest, Naive Bayes, KNN, Gradient Boosting, AdaBoost",Binary,No,"The number of vulnerabilities in open source libraries is increasing rapidly. However, the majority of them do not go through public disclosure. These unidentified vulnerabilities put developers' products at risk of being hacked since they are increasingly relying on open source libraries to assemble and build software quickly. To find unidentified vulnerabilities in open source libraries and secure modern software development, we describe an efficient automatic vulnerability identification system geared towards tracking large-scale projects in real time using natural language processing and machine learning techniques. Built upon the latent information underlying commit messages and bug reports in open source projects using GitHub, JIRA, and Bugzilla, our K-fold stacking classifier achieves promising results on vulnerability identification. Compared to the state of the art SVM-based classifier in prior work on vulnerability identification in commit messages, we improve precision by 54.55% while maintaining the same recall rate. For bug reports, we achieve a much higher precision of 0.70 and recall rate of 0.71 compared to existing work. Moreover, observations from running the trained model at SourceClear in production for over 3 months has shown 0.83 precision, 0.74 recall rate, and detected 349 hidden vulnerabilities, proving the effectiveness and generality of the proposed approach. ",,https://docs.google.com/document/d/12x3jkjgXfF7KFo8XfqXS1RPLcjkkJnT1dbl1ujC3fzw/edit?usp=sharing
,dam2018automatic,Java,Existing vulnerability detection approaches suffer from inability of features to represent semantic and syntactic features wrestling in inaccurate vulnerability detection,Automatic Feature Learning for Predicting Vulnerable Software Components,Semantic,Benchmark,N.A,N.A,"F-Droid, Android IOS",AST,Code,Source code,Token,N.A,LSTM,Token vector embedding,N.A,"Theano, Keras/TensorFlow",DL,RNN,LSTM,Binary,No,"Code flaws or vulnerabilities are prevalent in software systems and can potentially cause a variety of problems including deadlock, hacking, information loss and system failure. A variety of approaches have been developed to try and detect the most likely locations of such code vulnerabilities in large code bases. Most of them rely on manually designing code features (e.g., complexity metrics or frequencies of code tokens) that represent the characteristics of the potentially problematic code to locate. However, all suffer from challenges in sufficiently capturing both semantic and syntactic representation of source code, an important capability for building accurate prediction models. In this paper, we describe a new approach, built upon the powerful deep learning Long Short Term Memory model, to automatically learn both semantic and syntactic features of code. Our evaluation on 18 Android applications and the Firefox application demonstrates that the prediction power obtained from our learned features is better than what is achieved by state of the art vulnerability prediction models, for both within-project prediction and cross-project prediction.",,https://docs.google.com/document/d/1EzwcG5NgRU1m7yCH58aC6i9PD3MIELN5FulI0A-mBDk/edit?usp=sharing
,shippey2019automatically,JAVA,existing traditional features cannot distinguish code regions of different semantics,Automatically identifying code features for software defect prediction using AST N grams,Semantic,Open Source Projects,"EJDT, ArgoUML, AspectJ, T1, T2, JMRI, SocialSDK, GenoViz, JBoss Reddeer, K Framework, JMOL",N.A,N.A,AST,Code,Source code,Graph,N.A,N-gram features,Others,N.A,"SZZ, JDK",Others,Others,n-gram models,Binary,No,"Identifying defects in code early is important. A wide range of static code metrics have been evaluated as potential defect indicators. Most of these metrics offer only high level insights and focus on particular pre-selected features of the code. None of the currently used metrics clearly performs best in defect prediction. We use Abstract Syntax Tree (AST) n-grams to identify features of defective Java code that improve defect prediction performance. Our approach is bottom-up and does not rely on pre-selecting any specific features of code. We use non-parametric testing to determine relationships between AST n-grams and faults in both open source and commercial systems. We build defect prediction models using three machine learning techniques.We show that AST n-grams are very significantly related to faults in some systems, with very large effect sizes. The occurrence of some frequently occurring AST n-grams in a method can mean that the method is up to three times more likely to contain a fault. AST n-grams can have a large effect on the performance of defect prediction models.We suggest that AST n-grams offer developers a promising approach to identifying potentially defective code.",,https://docs.google.com/document/d/1cq11trzKDyh-CkMJ6DOFLxsiBlB0CNPeso86_UsrHFA/edit?usp=sharing
,wang2016automatically,JAVA,existing traditional features cannot distinguish code regions of different semantics,Automatically learning semantic features for defect prediction,Semantic,Hybrid,"ant, camel, jEdit, log4j, lucence, xalan, xerces, ivy, synapse, poi",N.A,PROMISE ,AST,Code,Source code,Tree,N.A,Token integer mapping,Others,N.A,N.A,DL,DNN,DBN,Binary,No,"Software defect prediction, which predicts defective code regions, can help developers find bugs and prioritize their testing efforts. To build accurate prediction models, previous studies focus on manually designing features that encode the characteristics of programs and exploring different machine learning algorithms. Existing traditional features often fail to capture the semantic differences of programs, and such a capability is needed for building accurate prediction models. To bridge the gap between programs' semantics and defect prediction features, this paper proposes to leverage a powerful representation-learning algorithm, deep learning, to learn semantic representation of programs automatically from source code. Specifically, we leverage Deep Belief Network (DBN) to automatically learn semantic features from token vectors extracted from programs' Abstract Syntax Trees (ASTs). Our evaluation on ten open source projects shows that our automatically learned semantic features significantly improve both within-project defect prediction (WPDP) and cross-project defect prediction (CPDP) compared to traditional features. Our semantic features improve WPDP on average by 14.7% in precision, 11.5% in recall, and 14.2% in F1. For CPDP, our semantic features based approach outperforms the state-of-the-art technique TCA+ with traditional features by 8.9% in F1.",,https://docs.google.com/document/d/17xptCyvl3xBG9DFS7LZU3O2nbwo85WDNkukeflqgw9I/edit?usp=sharing
,jeon2021autovas,C/C++,"Existing deep learning models for vulnerability detection do not consider correlations among source code tokens inside source code snippets. Also, they are highly dependent on size and quality of training data.",AutoVAS An automated vulnerability analysis system with a deep learning approach,Semantic,Benchmark,N.A,N.A,"SARD, NVD",XFG,Code,Source code,Graph,Token,"Word2Vec, GloVe, FastText",Token vector embedding,N.A,Keras/TensorFlow,DL,RNN,"LSTM, ‌BiLSTM, GRU, BGRU",Binary,no,"Owing to the advances in automated hacking and analysis technologies in recent years, numerous software security vulnerabilities have been announced. Software vulnerabilities are increasing rapidly, whereas methods to analyze and cope with them depend on manual analyses, which result in a slow response. In recent years, studies concerning the prediction of vulnerabilities or the detection of patterns of previous vulnerabilities have been conducted by applying deep learning algorithms in an automated vulnerability search based on source code. However, existing methods target only certain security vulnerabilities or make limited use of source code to compile information. Few studies have been conducted on methods that represent source code as an embedding vector. Thus, this study proposes a deep learning-based automated vulnerability analysis system (AutoVAS) that effectively represents source code as embedding vectors by using datasets from various projects in the National Vulnerability Database (NVD) and Software Assurance Reference Database (SARD). To evaluate AutoVAS, we present and share a dataset for deep learning models. Experimental results show that AutoVAS achieves a false negative rate (FNR) of 3.62%, a false positive rate (FPR) of 1.88%, and an F1-score of 96.11%, which represent lower FNR and FPR values than those achieved by other approaches. We further apply AutoVAS to nine open-source projects and detect eleven vulnerabilities, most of which are missed by the other approaches we experimented with. Notably, we discovered three zero-day vulnerabilities, two of which were patched after being informed by AutoVAS. The other vulnerability received the Common Vulnerabilities and Exposures (CVE) ID after being detected by AutoVAS.",,https://docs.google.com/document/d/1gPU6y_yMY1oIZ3plmPyiRJLgRh99VLMY4va_IbxCe8k/edit?usp=sharing
,tian2020bvdetector,C/C++,"Existing static binary vulnerability detection methods often manually construct vulnerability patterns to analyse binary code, which are highly dependent on the expert's experience. Moreover, the fine distinctions between the vulnerable code and the non-vulnerable code are difficult to identify, which often leads to a high false positive rate or a high false negative rate.",BVDetector: A program slice based binary code vulnerability intelligent detection system,Rely on expert rules,Benchmark,N.A,N.A,SARD,XFG,Code,Binary code,Graph,N.A,Word2vec,Token vector embedding,"Memory Corruption, Number Handling, Memory Destruction, Numerical Processing","Keras/TensorFlow, Angr, Checkmarx",DL,RNN,"RNN, LSTM, ‌BiLSTM, GRU, BRNN, BGRU",Binary,No,"Software vulnerability detection is essential to ensure cybersecurity. Currently, most software is published in binary form, thus researchers can only detect vulnerabilities in these software by analysing binary programs. Although existing research approaches have made a substantial contribution to binary vulnerability detection, there are still many deficiencies, such as high false positive rate, detection with coarse granularity, and dependence on expert experience. The goal of this study is to perform fine-grained intelligent detection on the vulnerabilities in binary programs. This leads us to propose a fine-grained representation of binary programs and introduce deep learning techniques to intelligently detect the vulnerabilities. We use program slices of library/API function calls to represent binary programs. Additionally, we design and construct a Binary Gated Recurrent Unit (BGRU) network model to intelligently learn vulnerability patterns and automatically detect vulnerabilities in binary programs.This approach yields the design and implementation of a program slice-based binary code vulnerability intelligent detection system called BVDetector. We show that BVDetector can effectively detect vulnerabilities related to library/API function calls in binary programs, which reduces the false positive rate and false negative rate of vulnerability detection. This paper proposes a program slice-based binary code vulnerability intelligent detection system called BVDetector. The experimental results show that BVDetector can effectively reduce the false negative rate and false positive rate of binary vulnerability detection.",,https://docs.google.com/document/d/1uuqYBF50QRXjp45Q7vN7V8HYxe1hsuBYIQ5V95GagQk/edit?usp=sharing
1,liu2020cd,C/C++,"The training and test datasets are assumed to be drawn from the same distribution. This assumption is not in most cases since the test data comes from different distribution. In practice, the distribution assumption is often violated because there are both emerging novel vulnerability types and new projects containing known vulnerability types. In both cases, the models trained on known vulnerability types and existing projects often fail to predict new vulnerabilities because they do not follow the same distributions as the models’ training data.",CD-VulD: Cross-Domain Vulnerability Discovery based on Deep Domain Adaptation,Training data problem,Hybrid,"LibTIFF, FFmpeg, LibPNG",N.A,"SARD, NVD, CWE119, CWE399",Code gadgets,Code,Source code,Graph,N.A,Word2vec,Token vector embedding,"CWE119, CWE399","Keras/TensorFlow, GenSim, CodeSensor",Hybrid,Hybrid,"LSTM, KNN",Binary,No,"A major cause of security incidents such as cyber attacks is rooted in software vulnerabilities. These vulnerabilities should ideally be found and fixed before the code gets deployed. Machine learning-based approaches achieve state-of-the-art performance in capturing vulnerabilities. These methods are predominantly supervised. Their prediction models are trained on a set of ground truth data where the training data and test data are assumed to be drawn from the same probability distribution. However, in practice, the test data often differs from the training data in terms of distribution because they are from different projects or they differ in the types of vulnerability. In this article, we present a new system for Cross Domain Software Vulnerability Discovery (CD-VulD) using deep learning (DL) and domain adaptation (DA). We employ DL because it has the capacity of automatically constructing high-level abstract feature representations of programs, which are likely of more cross-domain useful than the handcrafted features driven by domain knowledge. The divergence between distributions is reduced by learning cross-domain representations. First, given software program representations, CD-VulD converts them into token sequences and learns the token embeddings for generalization across tokens. Next, CD-VulD employs a deep feature model to build abstract high-level presentations based on those sequences. Then, the metric transfer learning framework (MTLF) technique is employed to learn cross-domain representations by minimizing the distribution divergence between the source domain and the target domain. Finally, the cross-domain representations are used to build a classifier for vulnerability detection. Experimental results show that CD-VulD outperforms the state-of-the-art vulnerability detection approaches by a wide margin. We make the new datasets publicly available so that our work is replicable and can be further improved.",,https://docs.google.com/document/d/1ntepJm0U0v12vqWfFiZzxQctTMsrMV1LJFlOk5oFiME/edit?usp=sharing
,yamaguchi2013chucky,C/C++,"According to the Rice theorem, an automatic approach for finding arbitrary vulnerabilities cannot exist. As a result of this limitation, security research has focused on discovering specific types of vulnerabilities. For example, the usage of potentially dangerous functions, such as strcpy and strcat, can be easily detected by scanning for these functions. Many of these approaches, however, are hard to operate effectively in practice and opaque to a security analyst",Chucky: Exposing Missing Checks in Source Code for Vulnerability Discovery,Specific vulnerability types,Open Source Projects,"Firefox, Linux Kernel, LibPNG, LibTIFF, Pidgin",N.A,N.A,Tokenization,Code,Source code,Token,N.A,Integer mapping,Others,Missing checks,N.A,Others,Others,distance measure,Fine grained interpretations,yes,"Uncovering security vulnerabilities in software is a key for operating secure systems. Unfortunately, only some security flaws can be detected automatically and the vast majority of vulnerabilities is still identified by tedious auditing of source code. In this paper, we strive to improve this situation by accelerating the process of manual auditing. We introduce Chucky, a method to expose missing checks in source code. Many vulnerabilities result from insufficient input validation and thus omitted or false checks provide valuable clues for finding security flaws. Our method proceeds by statically tainting source code and identifying anomalous or missing conditions linked to security-critical objects.In an empirical evaluation with five popular open-source projects, Chucky is able to accurately identify artificial and real missing checks, which ultimately enables us to uncover 12 previously unknown vulnerabilities in two of the projects (Pidgin and LibTIFF).",,https://docs.google.com/document/d/1M3qCQ0RnA8ZDJJjjuNmAGOaK_BFY5hb4Nz4L-n38K20/edit?usp=sharing
,wang2020combining,C/C++,"prior LSTM-based methods only capture the shallow, surface structure of the source code text and fail to capitalize on the rich and well-defined semantics of the program structure. As shown in our evaluation, existing LSTM-like approaches often give poor accuracy, either missing vulnerabilities or giving overwhelmingly false-positive results.",Combining graph based learning with automated data collection for code vulnerability detection,LSTM performance problem,Hybrid,"FFmpeg, ImageMagick, Linux Kernel, OpenSC, rdesktop",GitHub,"SARD, NVD, SAP, ZvD",AST,Code,Source code,Tree,N.A,Word2vec,Graph embedding,"CWE-400, CWE-404, CWE-369, CWE-191, CWE-476, CWE-078, CWE-772, CWE-020, CWE-287, CWE-467, CWE-573, CWE-190, CWE-119, CWE-770, CWE-668, CWE-200, CWE-610, CWE-754, CWE-074, CWE-666, CWE-704, CWE-138, CWE-362, CWE-665, CWE-758, CWE-670, CWE-077, CWE-469, CWE-676, CWE-834","Keras/TensorFlow, scikit-learn, Soot, ANTLR, Joern",DL,Hybrid,"GGNN, GRU",Binary,No,"This paper presents FUNDED (Flow-sensitive vUl-Nerability coDE Detection), a novel learning framework for building vulnerability detection models. Funded leverages the advances in graph neural networks (GNNs) to develop a novel graph-based learning method to capture and reason about the program’s control, data, and call dependencies. Unlike prior work that treats the program as a sequential sequence or an untyped graph, Funded learns and operates on a graph representation of the program source code, in which individual statements are connected to other statements through relational edges. By capturing the program syntax, semantics and flows, Funded finds better code representation for the downstream software vulnerability detection task. To provide sufficient training data to build an effective deep learning model, we combine probabilistic learning and statistical assessments to automatically gather high-quality training samples from open-source projects. This provides many real-life vulnerable code training samples to complement the limited vulnerable code samples available in standard vulnerability databases. We apply Funded to identify software vulnerabilities at the function level from program source code. We evaluate Funded on large real-world datasets with programs written in C, Java, Swift and Php, and compare it against six state-of-the-art code vulnerability detection models. Experimental results show that Funded significantly outperforms alternative approaches across evaluation settings.",,https://docs.google.com/document/d/1l2HpUdRoQFoys0fnHDTovOIVp7hoqmT-lzHJrx0-XaE/edit?usp=sharing
,liu2021combining,Solidity,"First, existing methods heavily rely on several expert-defined hard rules (or patterns) to detect smart contract vulnerability. Second, since the rules are contributed by a few ‘centralized’ experts who develop the detection tools, their scalability is inherently limited",Combining Graph Neural Networks with Expert Knowledge for Smart Contract Vulnerability Detection,Rely on expert rules,Benchmark,N.A,N.A,"ESC, VSC",Contract Graph,Code,Source code,Graph,N.A,Graph embedding,Graph embedding,N.A,Keras/TensorFlow,DL,GNN,GCN,Binary,No,"Smart contract vulnerability detection draws extensive attention in recent years due to the substantial losses caused by hacker attacks. Existing efforts for contract security analysis heavily rely on rigid rules defined by experts, which are labor-intensive and non-scalable. More importantly, expert-defined rules tend to be error-prone and suffer the inherent risk of being cheated by crafty attackers. Recent researches focus on the symbolic execution and formal analysis of smart contracts for vulnerability detection, yet to achieve a precise and scalable solution. Although several methods have been proposed to detect vulnerabilities in smart contracts, there is still a lack of effort that considers combining expert-defined security patterns with deep neural networks. In this paper, we explore using graph neural networks and expert knowledge for smart contract vulnerability detection. Specifically, we cast the rich control- and data- flow semantics of the source code into a contract graph. To highlight the critical nodes in the graph, we further design
a node elimination phase to normalize the graph. Then, we propose a novel temporal message propagation network to extract the graph feature from the normalized graph, and combine the graph feature with designed expert patterns to yield a final detection system. Extensive experiments are conducted on all the smart contracts that have source code in Ethereum and VNT Chain platforms. Empirical results show significant accuracy improvements over the state-of-the-art methods on three types of vulnerabilities, where the detection accuracy of our method reaches 89.15, 89.02, and 83.21 percent for reentrancy, timestamp dependence, and infinite loop vulnerabilities, respectively.",,
,phan2017convolutional,C/C++,"Capture deep hidden semantic information from programs, lack of considering execution flow of programs",Convolutional neural networks over control flow graphs for software defect prediction,Semantic,Open Source Projects,"FLOW016, MNMX, SUBINC, SUMTRIAN",N.A,N.A,CFG,Code,Binary code,Graph,N.A,Graph embedding,Graph embedding,N.A,"Pycparser, RSM tool",DL,GNN,DGCNN,Multi label,No,"Existing defects in software components is unavoidable and leads to not only a waste of time and money but also many serious consequences. To build predictive models, previous studies focus on manually extracting features or using tree representations of programs, and exploiting different machine learning algorithms. However, the performance of the models is not high since the existing features and tree structures often fail to capture the semantics of programs. To explore deeply programs’ semantics, this paper proposes to leverage precise graphs representing program execution flows, and deep neural networks for automatically learning defect features. Firstly, control flow graphs are constructed from the assembly instructions obtained by compiling source code; we thereafter apply multi-view multi-layer directed graph-based convolutional neural networks (DGCNNs) to learn semantic features. The experiments on four real-world datasets show that our method significantly outperforms the baselines including several other deep learning approaches.",,https://docs.google.com/document/d/1FDh9oz0s5dqq_fMEFI6vmcXtuWwg_Jah6Io7wRwcodA/edit?usp=sharing
,nguyen2020deep,C/C++,Binary vulnerability detection,Deep cost sensitive kernel machine for binary software vulnerability detection,Others,Hybrid,"FFmpeg, LibTIFF, LibPNG, VLC, Pidgin, Asterisk",N.A,NDSS,Tokenization,Code,Binary code,Token,N.A,One hot embedding,Others,"CWE-119, CWE399","Keras/TensorFlow, objdump, Capstone",ML,N.A,Kernel Machines,Binary,No,"Owing to the sharp rise in the severity of the threats imposed by software vulnerabilities, software vulnerability detection has become an important concern in the software industry, such as the embedded systems industry, and in the field of computer security. Software vulnerability detection can be carried out at the source code or binary level. However, the latter is more impactful and practical since when using commercial software, we usually only possess binary software. In this paper, we leverage deep learning and kernel methods to propose the Deep Cost-sensitive Kernel Machine, a method that inherits the advantages of deep learning methods in efficiently tackling structural data and kernel methods in learning the characteristic of vulnerable binary examples with high generalization capacity. We conduct experiments on two real-world binary datasets. The experimental results have shown a convincing outperformance of our proposed method over the baselines.",,
,liu2019deepbalance,C/C++,Class imbalance problem,DeepBalance: Deep-learning and fuzzy oversampling for vulnerability detection,Class imbalance problem,Hybrid,"LibTIFF, LibPNG, FFmpeg","GitHub, CVE",NVD,AST,Code,Source code,Tree,N.A,Word2vec,Token vector embedding,N.A,CodeSensor,Hybrid,Hybrid,"LSTM, Random Forest",Binary,No,"Software vulnerability has long been an important but critical research issue in cybersecurity. Recently, the machine learning (ML)-based approach has attracted increasing interest in the research of software vulnerability detection. However, the detection performance of existing ML-based methods require further improvement. There are two challenges: one is code representation for ML and the other is class imbalance between vulnerable code and nonvulnerable code. To overcome these challenges, this article develops a DeepBalance system, which combines the new ideas of deep code representation learning and fuzzy-based class rebalancing. We design a deep neural network with bidirectional long short-term memory to learn invariant and discriminative code representations from labeled vulnerable and nonvulnerable code. Then, a new fuzzy oversampling method is employed to rebalance the training data by generating synthetic samples for the class of vulnerable code. To evaluate the performance of the new system, we carry out a series of experiments in a real-world ground-truth dataset that consists of the code from the projects of LibTIFF, LibPNG, and FFmpeg. The results show that the proposed new system can significantly improve the vulnerability detection performance. For example, the improvement is 15% in terms of F-measure.",,https://docs.google.com/document/d/1y50PBGAwhOGNA9x_vJL7S9ZRGcMDOVMjFgMU0FdSw5Q/edit?usp=sharing
,pradel2018deepbugs,Java script,"Natural language elements in source code, e.gThe names of variables and functions, convey useful information. However, most existing bug detection tools ignore this information and therefore miss some classes of bugs. The few existing name-based bug detection approaches reason about names on a syntactic level and rely on manually designed and tuned algorithms to detect bugs.",DeepBugs a learning approach to name based bug detection,Consider different code fragments,Repository,N.A,GitHub,N.A,Tokenization,Code,Source code,Token,N.A,Word2vec,Token vector embedding,"Swapped arguments, Wrong binary operator, Wrong binary operand ","Keras/TensorFlow, Acorn JavaScript parser",DL,DNN,Feed Forward,Binary,No,"Natural language elements in source code, e.g., the names of variables and functions, convey useful information. However, most existing bug detection tools ignore this information and therefore miss some classes of bugs. The few existing name-based bug detection approaches reason about names on a syntactic level and rely on manually designed and tuned algorithms to detect bugs. This paper presents DeepBugs, a learning approach to name-based bug detection, which reasons about names based on a semantic representation and which automatically learns bug detectors instead of manually writing them. We formulate bug detection as a binary classification problem and train a classifier that distinguishes correct from incorrect code. To address the challenge that effectively learning a bug detector requires examples of both correct and incorrect code, we create likely incorrect code examples from an existing corpus of code through simple code transformations. A novel insight learned from our work is that learning from artificially seeded bugs yields bug detectors that are effective at finding bugs in real-world code. We implement our idea into a framework for learning-based and name-based bug detection. Three bug detectors built on top of the framework detect accidentally swapped function arguments, incorrect binary operators, and incorrect operands in binary operations. Applying the approach to a corpus of 150,000 JavaScript files yields bug detectors that have a high accuracy (between 89% and 95%), are very efficient (less than 20 milliseconds per analyzed file), and reveal 102 programming mistakes (with 68% true positive rate) in real-world code.",,https://docs.google.com/document/d/1Sia7xN0MF_bf7iz-K7F1DsSXJocMCeW2uBrfNDIkXyU/edit?usp=sharing
,le2021deepcva,Java,"However, there is a lack of effort to assess vulnerability-contributing commits right after they are detected to provide timely information about the exploitability, impact and severity of SVs",DeepCVA: Automated Commit-level Vulnerability Assessment with Deep Multi-task Learning,"However, there is a lack of effort to assess vulnerability-contributing commits right after they are detected to provide timely information about the exploitability, impact and severity of SVs",Hybrid,N.A,GitHub,"NVD, VulasDB",Tokenization,Code,Source code,Token,N.A,N-gram features,Others,N.A,"NLTK, PorterStemmer",DL,Hybrid,"GRU, CNN",Multi label,No,"It is increasingly suggested to identify Software Vulnerabilities (SVs) in code commits to give early warnings about potential security risks. However, there is a lack of effort to assess vulnerability-contributing commits right after they are detected to provide timely information about the exploitability, impact and severity of SVs. Such information is important to plan and prioritize the mitigation for the identified SVs. We propose a novel Deep multi-task learning model, DeepCVA, to automate seven Commit-level Vulnerability Assessment tasks simultaneously based on Common Vulnerability Scoring System (CVSS) metrics. We conduct large-scale experiments on 1,229 vulnerability-contributing commits containing 542 different SVs in 246 real-world software projects to evaluate the effectiveness and efficiency of our model. We show that DeepCVA is the best-performing model with 38% to 59.8% higher Matthews Correlation Coefficient than many supervised and unsupervised baseline models. DeepCVA also requires 6.3 times less training and validation time than seven cumulative assessment models, leading to significantly less model maintenance cost as well. Overall, DeepCVA presents the first effective and efficient solution to automatically assess SVs early in software systems.",,
,hoang2019deepjit,N.A,"Metric-based features however do not represent the semantic and syntactic structure of the actual code changes. In many cases, two different code changes which have exactly the same metrics (e.g. the number of lines deleted and added) may generate different behaviour when executed, and thus have a different likelihood of defectiveness",DeepJIT: An End-To-End Deep LearningFramework for Just-In-Time Defect Prediction,Semantic,Open Source Projects,"QT, OpenStack",N.A,N.A,"Textual, code change",Hybrid,Hybrid,Token,N.A,CNN,Token vector embedding,N.A,NLTK,DL,CNN,CNN,Binary,No,"Software quality assurance efforts often focus on identifying defective code. To find likely defective code early, change-level defect prediction - aka. Just-In-Time (JIT) defect prediction - has been proposed. JIT defect prediction models identify likely defective changes and they are trained using machine learning techniques with the assumption that historical changes are similar to future ones. Most existing JIT defect prediction approaches make use of manually engineered features. Unlike those approaches, in this paper, we propose an end-to-end deep learning framework, named DeepJIT, that automatically extracts features from commit messages and code changes and use them to identify defects. Experiments on two popular software projects (i.e., QT and OPENSTACK) on three evaluation settings (i.e., cross-validation, short-period, and long-period) show that the best variant of DeepJIT (DeepJIT-Combined), compared with the best performing state-of-the-art approach, achieves improvements of 10.36-11.02% for the project QT and 9.51-13.69% for the project OPENSTACK in terms of the Area Under the Curve (AUC).",,
,cheng2021deepwukong,C/C++,"low-level memory error, shallow code features (code tokens and ASTs), lack of considering comprehensive code features (data and control dependencies), coarse grained prediction granularities such as function or file level, ",DeepWukong: Statically Detecting Software Vulnerabilities Using Deep Graph Neural Network,Semantic,Hybrid,"Lua, redis",GitHub,SARD,XFG,Code,Source code,Graph,N.A,"doc2vec, GCN, GAT, k-GNNS",Graph embedding,"CWE-119, CWE-20, CWE-125, CWE-190, CWE-22 CWE-99, CWE-787, CWE-254, CWE-400, CWE-78","PyTorch, mongrel2",DL,GNN,"GCN, GAT, GNN",Binary,No,"Static bug detection has shown its effectiveness in detecting well-defined memory errors, e.g., memory leaks, buffer overflows, and null dereference. However, modern software systems have a wide variety of vulnerabilities. These vulnerabilities are extremely complicated with sophisticated programming logic, and these bugs are often caused by different bad programming practices, challenging existing bug detection solutions. It is hard and labor-intensive to develop precise and efficient static analysis solutions for different types of vulnerabilities, particularly for those that may not have a clear specification as the traditional well-defined vulnerabilities. This article presents DeepWukong, a new deep-learning-based embedding approach to static detection of software vulnerabilities for C/C++ programs. Our approach makes a new attempt by leveraging advanced recent graph neural networks to embed code fragments in a compact and low-dimensional representation, producing a new code representation that preserves high-level programming logic (in the form of control- and data-flows) together with the natural language information of a program. Our evaluation studies the top 10 most common C/C++ vulnerabilities during the past 3 years. We have conducted our experiments using 105,428 real-world programs by comparing our approach with four well-known traditional static vulnerability detectors and three state-of-the-art deep-learning-based approaches. The experimental results demonstrate the effectiveness of our research and have shed light on the promising direction of combining program analysis with deep learning techniques to address the general static code analysis challenges.",,https://docs.google.com/document/d/1bfljfG13bDunyBYdCOS9eL_h8iuasmTNL3h3douI00c/edit?usp=sharing
,zhou2019devign,C/C++,"learning comprehensive program semantics to characterize vulnerabilities of high diversity and complexity in real source code, treat the source code as a flat sequence, labeling part of data by static analyzers, training vulnerability detection models using ariticial codes which is far from real world projects",Devign Effective vulnerability identification by learning comprehensive program semantics via graph neural networks,Semantic,Open Source Projects,"Linux Kernel, QEMU, Wireshark, FFmpeg",N.A,N.A,XPG,Code,Source code,Graph,N.A,Word2vec,Graph embedding,N.A,"Joern, PyTorch, GenSim",DL,GNN,GNN,Binary,No,"Vulnerability identification is crucial to protect the software systems from attacks for cyber security. It is especially important to localize the vulnerable functions among the source code to facilitate the fix. However, it is a challenging and tedious process, and also requires specialized security expertise. Inspired by the work on manually-defined patterns of vulnerabilities from various code representation graphs and the recent advance on graph neural networks, we propose Devign, a general graph neural network based model for graph-level classification through learning on a rich set of code semantic representations. It includes a novel Conv module to efficiently extract useful features in the learned rich node representations for graph-level classification. The model is trained over manually labeled datasets built on 4 diversified large-scale open-source C projects that incorporate high complexity and variety of real source code instead of synthesis code used in previous works. The results of the extensive evaluation on the datasets demonstrate that Devign outperforms the state of the arts significantly with an average of 10.51% higher accuracy and 8.68% F1 score, increases averagely 4.66% accuracy and 6.37% F1 by the Conv module.",,https://docs.google.com/document/d/1HlJdL768f0jBf3uUcpp2REHqqBJwSKvh_3Rdlpn3uAo/edit?usp=sharing
,kronjee2018discovering,php,"An obvious limitation is that only the vulnerabilities covered by the rule set can be discovered. The first static analysis tools appeared early 2000 (such as Flawfinder, ITS4, and RATS). ",Discovering software vulnerabilities using data flow analysis and machine learning,High false positive of static analyzers,Benchmark,N.A,N.A,"NVD, SAMATE",CFG,Code,Source code,Graph,N.A,CFG integer mapping,Others,"CWE-79, CWE-89","scikit-learn, Weka, xgboost",ML,N.A,"Decision tree, Random Forest, Logistic Regression, Naive Bayes, TAN",Binary,No,"We present a novel method for static analysis in which we combine data-flow analysis with machine learning to detect SQL injection (SQLi) and Cross-Site Scripting (XSS) vulnerabilities in PHP applications. We assembled a dataset from the National Vulnerability Database and the SAMATE project, containing vulnerable PHP code samples and their patched versions in which the vulnerability is solved. We extracted features from the code samples by applying data-flow analysis techniques, including reaching definitions analysis, taint analysis, and reaching constants analysis. We used these features in machine learning to train various probabilistic classifiers. To demonstrate the effectiveness of our approach, we built a tool called WIRECAML, and compared our tool to other tools for vulnerability detection in PHP code. Our tool performed best for detecting both SQLi and XSS vulnerabilities. We also tried our approach on a number of open-source software applications, and found a previously unknown vulnerability in a photo-sharing web application.",,https://docs.google.com/document/d/1lVTHmhp_ghJrJOZUuhTqR64JaEgdX3Aa-AhzDfniQWE/edit?usp=sharing
,3172102,N.A,"Previous deep learning approaches are limited at comprehending how data values are transferred and used within source codes. In order to achieve this, the knowledge in the entire source code is needed. Also one needs to track  the data values stored in different variables and methods. Another major limitation of existing deep learning models is not being able to keep track of how values are changed. This restriction greatly limits their usefulness in program analysis since run-time bugs and errors are usually much more difficult to detect and thus are often treated with greater importance.",End-to-end prediction of buffer overruns from raw source code via neural memory networks,Support Flow Analysis,Benchmark,N.A,N.A,Juliet Test Suit,Tokenization,Code,Source code,Token,N.A,One hot embedding,Others,CWE-122,Keras/TensorFlow,DL,DNN,Memory Neural Networks,N.A,N.A,"Detecting buffer overruns from a source code is one of the most common and yet challenging tasks in program analysis. Current approaches based on rigid rules and handcrafted features are limited in terms of flexible applicability and robustness due to diverse bug patterns and characteristics existing in sophisticated real-world software programs. In this paper, we propose a novel, data-driven approach that is completely end-to-end without requiring any hand-crafted features, thus free from any program language-specific structural limitations. In particular, our approach leverages a recently proposed neural network model called memory networks that have shown the state-of-the-art performances mainly in question-answering tasks. Our experimental results using source code samples demonstrate that our proposed model is capable of accurately detecting different types of buffer overruns. We also present in-depth analyses on how a memory network can learn to understand the semantics in programming languages solely from raw source codes, such as tracing variables of interest, identifying numerical values, and performing their quantitative comparisons.",,https://docs.google.com/document/d/1NMlwdS1m0mwekZk9VZUUJzQNptZ1-XgRgbl_R8P3nsg/edit?usp=sharing
,pascarella2019fine,*,"Existing commit level defect prediction approaches are too coarse grained, meaning that they merely classify whether files in a commit are defective or not. However, developers often need to know which parts of files are defective.",Fine grained just in time defect prediction,Granularity,Hybrid,"Accumulo, Angular-js, Gerrit, Gimp, Hadoop, JDeodorant, Jetty, JRuby, OpenJPA","GitHub, Bugzilla",N.A,Commit Metrics,Numerical,Commit Metrics,Commit Metrics,N.A,commit metrics,Others,N.A,"Keras/TensorFlow, NLTK, SZZ",ML,N.A,"Logistic Regression, ADTree, Naive Bayes, Random Forest",Binary,No,"Defect prediction models focus on identifying defect-prone code elements, for example to allow practitioners to allocate testing resources on specific subsystems and to provide assistance during code reviews. While the research community has been highly active in proposing metrics and methods to predict defects on long-term periods (i.e.,at release time), a recent trend is represented by the so-called short-term defect prediction (i.e.,at commit-level). Indeed, this strategy represents an effective alternative in terms of effort required to inspect files likely affected by defects. Nevertheless, the granularity considered by such models might be still too coarse. Indeed, existing commit-level models highlight an entire commit as defective even in cases where only specific files actually contain defects. In this paper, we first investigate to what extent commits are partially defective; then, we propose a novel fine-grained just-in-time defect prediction model to predict the specific files, contained in a commit, that are defective. Finally, we evaluate our model in terms of (i) performance and (ii) the extent to which it decreases the effort required to diagnose a defect. Our study highlights that: (1) defective commits are frequently composed of a mixture of defective and non-defective files, (2) our fine-grained model can accurately predict defective files with an AUC-ROC up to 82% and (3) our model would allow practitioners to save inspection efforts with respect to standard just-in-time techniques.",,https://docs.google.com/document/d/1z5rZqRV7uPQ__qrN_hC6dPMhxdrZq30uV-I9oqi8WrA/edit?usp=sharing
,zeng2021gcn2defect,Java,Static code attributes are ignoring the context information may have a fatal impact on understanding the program,GCN2defect Graph Convolutional Networks for SMOTETomek-based Software Defect Prediction,High false positive of static analyzers,Hybrid,"Ant, Camel, Ivy, jEdit, Lucene, Poi, Velocity, Xalan",N.A,PROMISE,CDN over files,Code,Source code,Graph,N.A,"node2vec, GCN",Graph embedding,N.A,N.A,DL,GNN,GCN,Binary,No,"With the introduction of network metrics into the field of software defect prediction, the dependency network of software modules is widely used. The network embedding models aim to represent nodes as low-dimensional vectors, thereby preserving the topological structure of the network. However, in software engineering, traditional network embedding models do not concern deep learning strategies, while recently, graph neural networks (GNNs) have been proved to be an effective deep learning framework for learning graph data. As a variant of GNN, graph convolution neural network (GCN) has achieved appealing results in node classification and link prediction. Inspired by the performance of GCN, we propose GCN2defect, which extends GCN to automatically learn to encode the software dependency network and ultimately improve software defect prediction. Specifically, we firstly construct a program's Class Dependency Network, and then use node2vec for embedded learning to obtain the structural features of the network automatically. After that, we combine the learned structural features with traditional software code features to initialize the attributes of nodes in the Class Dependency Network. Next, we feed the dependency network to GCN to get much deeper representation of the class. Meanwhile, to enhance the accuracy of prediction, we also employ the SMOTETomek sampling to solve the problem of data imbalance. Finally, we evaluate the proposed method on eight open-source programs and demonstrate that, on average, GCN2defect improves the state-of-the-art approach by 6.84% ~ 23.85% in terms of the F-measure.",,
,yan2021han,C/C++,"Existing binary vulnerability detection approaches do not consider the context between an instruction’s elements (opcode, registers, etc.) during embedding to vector representation. Also, the crucial regions that are related to vulnerability are not highlighted when extracting features of the vulnerable code.",HAN BSVD A hierarchical attention network for binary software vulnerability detection,Context modeling,Benchmark,N.A,N.A,"Juliet Test Suit, ICLR2019",Tokenization,Code,Binary code,Token,N.A,"Word2vec, Bi-GRU",Token vector embedding,"CWE-121, CWE-119, CWE399","IDA Pro, Keras/TensorFlow",DL,Hybrid,"BGRU, TextCNN",Binary,No,"Deep learning has shown effectiveness in binary software vulnerability detection due to its outstanding feature extraction capability independent of human expert experience. However, detection approaches such as Instruction2vec still have the following defects: (1) the context between an instruction’s elements (opcode, registers, etc.) is not fully incorporated when embedding a single instruction into its vector representation; (2) the crucial regions that related to vulnerability are not highlighted when extracting features of the vulnerable code. In this paper, we propose a hierarchical attention network for binary software vulnerability detection (HAN-BSVD). Through HAN-BSVD, the contextual information is first enriched by the preprocessor with unifying jump address and normalizing instruction, and then preserved by the instruction embedding network that composed of Bi-GRU and word-attention module; the local features are captured and the crucial regions are highlighted by the feature extraction network that composed of Text-CNN and spatial-attention module. The proposed approach is evaluated on the Juliet Test Suite dataset and the ICLR19 dataset, detection result performs better than the other compared approaches. Extensive ablation studies are also conducted to further prove the effectiveness of each design choice.",,https://docs.google.com/document/d/1l7M3dO_inl6GbMtAZt4hyfcwJ1DtiblgX5nhTfCuxVY/edit?usp=sharing
,dinella2020hoppity,JavaScript,"Pinpointing and fixing complex bugs  (i.e. bugs that require adding or deleting statements to fix) Effective against a broad spectrum of programming errors, such as using wrong operators or identifiers, accessing undefined properties, mishandling variable scopes, triggering type incompatibilities, among many others.  Addressed bug detection of JS programs which is hard to detect because of its diverse and complicated nature and lack of tooling to support such operation.",Hoppity Learning graph transformations to detect and fix bugs in programs,Granularity,Repository,N.A,GitHub,N.A,AST,Code,Source code,Tree,N.A,GNN,Graph embedding,N.A,"PyTorch, shift-ast, fast-json-patch",DL,Hybrid,"GNN, LSTM",Fine grained interpretations,Yes,"We present a learning-based approach to detect and fix a broad range of bugs in Javascript programs. We frame the problem in terms of learning a sequence of graph transformations: given a buggy program modeled by a graph structure, our model makes a sequence of predictions including the position of bug nodes and corresponding graph edits to produce a fix. Unlike previous works built upon deep neural networks, our approach targets bugs that are more diverse and complex in nature (i.e. bugs that require adding or deleting statements to fix). We have realized our approach in a tool called HOPPITY. By training on 290,715 Javascript code change commits on Github, HOPPITY correctly detects and fixes bugs in 9,490 out of 36,361 programs in an end-to-end fashion. Given the bug location and type of
 he fix, HOPPITY also outperforms the baseline approach by a wide margin.",,https://docs.google.com/document/d/11-P6PjbuoU-zIjY-5mVTd68mgUAI_d2eQn_9M_6lGNc/edit?usp=sharing
,huang2021hunting,Solidity,"However, the rapid evolution of Solidity compilers has led to dozens of compiler versions and different versions may generate different bytecode even for the same source code pieces. The diversity of bytecode generation can impede bytecode matching. Second, a vulnerability generally involves very few statements but vulnerable smart contracts, either the seeds or targets, usually contain many statements that are irrelevant to the vulnerabilities",Hunting Vulnerable Smart Contracts via Graph Embedding Based Bytecode Matching,Irrelevant code fragments,Repository,N.A,"Etherscan, CVE",N.A,CFG,Code,Binary code,Graph,N.A,graph2vec,Graph embedding,"CWE-190, Reenterancy, Bad randomness, unprotected ownership, mishandled exceptions",Mist,Others,Others,Similarity Measure,similarity,No,"Smart contract vulnerabilities have attracted lots of concerns due to the resultant financial losses. Matching-based detection methods extrapolating known vulnerabilities to unknown have proven to be effective in other platforms. However, directly adopting the technique to smart contracts is obstructed by two issues, i.e., diversity of bytecode generation resulting from the rapid evolution of compilers and interference of noise code easily caused by the homogeneous business logics. To address the problems, we propose contract bytecode-oriented normalization and slicing techniques to augment bytecode matching. Specifically, we conduct data- and instruction-level normalizations to uniform the bytecode generated by different compilers, and enforce contract-specific slicing by tracking data- and control-flows with simulated bytecode executions to prune the noise code as far as possible. Based on the above techniques, we design an unsupervised graph embedding algorithm to encode the code graphs into quantitatively comparable vectors. The potentially vulnerable smart contracts can be identified by measuring the similarities between their vectors and known vulnerable ones. Our evaluations have shown the efficiency (0.47 seconds per contract on average), effectiveness (160 verified true positives) and high precision (91.95% for top-ranked). It is worth noting that, we also identify dozens of honeypot contracts, further demonstrating the capability of our method.",,
,3360588,Java,"Mining-based approaches still have a key limitation in a very high false positive rate due to the fact that it cannot distinguish the cases of incorrect code versus infrequent/rare code. The deep learning-based approaches are still limited to detect bugs in individual methods without investigating the dependencies among different yet relevant methods. In practice, there exist several cases that bugs occur across more than one method. That is, to decide whether a given method is buggy or not, a model needs to consider other methods that have data and/or control dependencies with the method under investigation",Improving bug detection via context based code representation learning and attention based neural networks,High false positive of static analyzers,Hybrid,"pig, avro, lucene-solr, hbase, flink, hive, cloudstack, camel",GitHub,N.A,"AST, CFG, PDG over functions",Code,Source code,Graph,N.A,"Node2vec, Word2vec, attention GRU",Token vector embedding,Bug detection,"Soot, Wala, JDT",DL,Hybrid,"GRU, CNN",Binary,No,"Bug detection has been shown to be an effective way to help developers in detecting bugs early, thus, saving much effort and time in software development process. Recently, deep learning-based bug detection approaches have gained successes over the traditional machine learning-based approaches, the rule-based program analysis approaches, and mining-based approaches. However, they are still limited in detecting bugs that involve multiple methods and suffer high rate of false positives. In this paper, we propose a combination approach with the use of contexts and attention neural network to overcome those limitations. We propose to use as the global context the Program Dependence Graph (PDG) and Data Flow Graph (DFG) to connect the method under investigation with the other relevant methods that might contribute to the buggy code. The global context is complemented by the local context extracted from the path on the AST built from the method’s body. The use of PDG and DFG enables our model to reduce the false positive rate, while to complement for the potential reduction in recall, we make use of the attention neural network mechanism to put more weights on the buggy paths in the source code. That is, the paths that are similar to the buggy paths will be ranked higher, thus, improving the recall of our model. We have conducted several experiments to evaluate our approach on a very large dataset with +4.973M methods in 92 different project versions. The results show that our tool can have a relative improvement up to 160% on F-score when comparing with the state-of-the-art bug detection approaches. Our tool can detect 48 true bugs in the list of top 100 reported bugs, which is 24 more true bugs when comparing with the baseline approaches. We also reported that our representation is better suitable for bug detection and relatively improves over the other representations up to 206% in accuracy.",,https://docs.google.com/document/d/1ozKkjaJjIVRdbJ-2_cTc_MQK6gaJZZNitvcNQScIp5U/edit
,3429444,C/C++,The framework is centered at identifying a small number of tokens that make important contributions to a particular prediction.,Interpreting deep learning based vulnerability detector predictions based on heuristic searching,Consider different code fragments,Benchmark,N.A,N.A,"SySeVR, VulDeePecker","XFG, functions",Code,Source code,Token,N.A,Word2vec,Token vector embedding,"CWE-680, CWE-789, CWE-189, CWE-761",Keras/TensorFlow,DL,Hybrid,"BGRU, BiLSTM, CNN",Binary,yes,"Detecting software vulnerabilities is an important problem and a recent development in tackling the problem is the use of deep learning models to detect software vulnerabilities. While effective, it is hard to explain why a deep learning model predicts a piece of code as vulnerable or not because of the black-box nature of deep learning models. Indeed, the interpretability of deep learning models is a daunting open problem. In this article, we make a significant step toward tackling the interpretability of deep learning model in vulnerability detection. Specifically, we introduce a high-fidelity explanation framework, which aims to identify a small number of tokens that make significant contributions to a detector’s prediction with respect to an example. Systematic experiments show that the framework indeed has a higher fidelity than existing methods, especially when features are not independent of each other (which often occurs in the real world). In particular, the framework can produce some vulnerability rules that can be understood by domain experts for accepting a detector’s outputs (i.e., true positives) or rejecting a detector’s outputs (i.e., false-positives and false-negatives). We also discuss limitations of the present study, which indicate interesting open problems for future research.",,https://docs.google.com/document/d/1_8CdioLGKq_XzAQaDj1nye1shZFzcJF1a3Vy-qlZc6U/edit?usp=sharing
,hin2022linevd,Java,How can we leverage the common attributes of assessment tasks to perform effective and efficient commit-level SV assessment,LineVD: Statement-level Vulnerability Detection using Graph Neural Networks,Commits,Hybrid,N.A,GitHub,NVD,code change,Code,Source code,Token,N.A,codeBERT,Token vector embedding,N.A,"PyTorch, GenSim, NLTK, scikit-learn, spacy, torchtext",DL,RNN,GRU,Multi label,No,"Current machine-learning based software vulnerability detection methods are primarily conducted at the function-level. However, a key limitation of these methods is that they do not indicate the specific lines of code contributing to vulnerabilities. This limits the ability of developers to efficiently inspect and interpret the predictions from a learnt model, which is crucial for integrating machine-learning based tools into the software development work-flow. Graph-based models have shown promising performance in function-level vulnerability detection, but their capability for statement-level vulnerability detection has not been extensively explored. While interpreting function-level predictions through explainable AI is one promising direction, we herein consider the statement-level software vulnerability detection task from a fully supervised learning perspective. We propose a novel deep learning framework, LineVD, which formulates statement-level vulnerability detection as a node classification task. LineVD leverages control and data dependencies between statements using graph neural networks, and a transformer-based model to encode the raw source code tokens. In particular, by addressing the conflicting outputs between function-level and statement-level information, LineVD significantly improve the prediction performance without vulnerability status for function code. We have conducted extensive experiments against a large-scale collection of real-world C/C++ vulnerabilities obtained from multiple real-world projects, and demonstrate an increase of 105% in F1-score over the current state-of-the-art.",,
,fu2022linevul,C/C++,"Despite the success of current data-driven approaches in the identification of software vulnerabilities, they are often limited to a coarse level of granularity. The model outputs often present developers with limited information for prediction outcome validation and interpretation, leading to extra efforts when evaluating and mitigating the software vulnerabilities",LineVul: A Transformer-based Line-Level Vulnerability Prediction,Granularity,Hybrid,N.A,CVE,Big-Vul,"functions, CDG, DDG",Code,Source code,Graph,N.A,codeBERT,Token vector embedding,"CWE-787, CWE-20, CWE-22, CWE-190, CWE-119, CWE-200, CWE-77","Transformers, PyTorch",DL,GNN,GAT,Binary,No,"Software vulnerabilities are prevalent in software systems, causing a variety of problems including deadlock, information loss, or system failures. Thus, early predictions of software vulnerabilities are critically important in safety-critical software systems. Various ML/DL-based approaches have been proposed to predict vulnerabilities at the file/function/method level. Recently, IVDetect (a graph-based neural network) is proposed to predict vulnerabilities at the function level. Yet, the IVDetect approach is still inaccurate and coarse-grained. In this paper, we propose LINEVUL, a Transformer-based line-level vulnerability prediction approach in order to address several limitations of the state-of-the-art IVDetect approach. Through an empirical evaluation of a large-scale real-world dataset with 188k+ C/C++ functions, we show that LINEVUL achieves (1) 160%-379% higher F1-measure for function-level predictions; (2) 12%-25% higher Top-10 Accuracy for line-level predictions; and (3) 29%-53% less Effort@20%Recall than the baseline approaches, highlighting the significant advancement of LINEVUL towards more accurate and more cost-effective line-level vulnerability predictions. Our additional analysis also shows that our LINEVUL is also very accurate (75%-100%) for predicting vulnerable functions affected by the Top-25 most dangerous CWEs, highlighting the potential impact of our LINEVUL in real-world usage scenarios.",,
,le2018maximal,C/C++,"Existing approaches are using hand crafted features, there is no extensive data set for binary vulnerability detection as source codes are not compilable, the datasets often suffer from shortage in labeled samples",Maximal divergence sequential autoencoder for binary software vulnerability detection,Rely on expert rules,Benchmark,N.A,N.A,NDSS,functions,Code,Binary code,Token,N.A,One hot embedding,Others,"CWE-119, CWE399","Keras/TensorFlow, Joern",DL,DNN,SEQUENTIAL AUTO-ENCODER,Binary,No,"Due to the sharp increase in the severity of the threat imposed by software vulnerabilities, the detection of vulnerabilities in binary code has become an important concern in the software industry, such as the embedded systems industry, and in the field of computer security. However, most of the work in binary code vulnerability detection has relied on handcrafted features which are manually chosen by a select few, knowledgeable domain experts. In this paper, we attempt to alleviate this severe binary vulnerability detection bottleneck by leveraging recent advances in deep learning representations and propose the Maximal Divergence Sequential Auto-Encoder. In particular, latent codes representing vulnerable and non-vulnerable binaries are encouraged to be maximally divergent, while still being able to maintain crucial information from the original binaries. We conducted extensive experiments to compare and contrast our proposed methods with the baselines, and the results show that our proposed methods outperform the baselines in all performance measures of interest.",,https://docs.google.com/document/d/1sYGdzKl8-sTOt9-eE4ak_CsHZwupgsvMPtkpFnyKC6Y/edit?usp=sharing
,zou2019mu,C/C++,"This paper addresses the previous and state-of-the-art paper called VulDeePecker in two folds; 1) VulDeePecker is a binary vulnerability detection meaning that it is only able to tell whether a component is buggy or not, 2) VulDeePecker can not tell us types of vulnerabilities, the type is important since it helps us to pinpoint the exact location of vulnerability which is very crucial for software testers. ",muVulDeePecker A deep learning based system for multiclass vulnerability detection,Granularity,Benchmark,N.A,N.A,"SARD, NVD",Code gadgets over functions,Code,Source code,Graph,N.A,Word2vec,Token vector embedding,N.A,"Keras/TensorFlow, Joern",DL,RNN,BiLSTM,Multi,No,"Multiclass Vulnerability Dataset (MVD) is a database for research on multiclass vulnerability detection with deep learning. The dataset is based on the NIST Software Assurance Reference Dataset (SARD) and National Vulnerability Database (NVD). Up to now, it has possessed 181641 code gadgets, covering 40 types of vulnerabilities. Each code gadget in MVD is composed of multiple program statements, which have direct or indirect data-dependence and control-dependence relationships with the library/API function calls. In total, the code gadgets in MVD are extracted from 33409 testcases of SARD and NVD, 138522 code gadgets of which are non-vulnerable and 43119 are vulnerable. In this repository, the compressed file mvd.txt.zip stores 181641 code gadgets and their corresponding labels. The file named label2CWE.txt records the mapping relationship between each label and the corresponding vulnerability. The folder source files contains 33,409 source files for extracting code gadgets.",,https://docs.google.com/document/d/1iSeN55RTNWG-MNo0MUMjb52Ny4yitXXKfvWT4rAbop0/edit?usp=sharing
,cao2022mvd,C/C++,"Flow Information Underutilization, Coarse Granularity, Fully Utilizing Flow Information, Fine Granularity",MVD: Memory-Related Vulnerability Detection Based on Flow-Sensitive Graph Neural Networks,Granularity,Hybrid,"Linux Kernel, FFmpeg, Asterisk, Libarchive, Libming, LibTIFF, Libav, LibPNG, QEMU, Wireshark","CVE, GitHub","NVD, SARD",PDG over functions,Code,Source code,Graph,N.A,"Doc2vec, FS-GNN",Graph embedding,"CWE-119, CWE-120, CWE-121, CWE-122, CWE-124, CWE-125, CWE-126, CWE-401, CWE-415, CWE-416, CWE-476, CWE-787, CWE-824","Keras/TensorFlow, Joern",DL,GNN,GNN,Binary,No,"Memory-related vulnerabilities constitute severe threats to the security of modern software. Despite the success of deep learning-based approaches to generic vulnerability detection, they are still limited by the underutilization of flow information when applied for detecting memory-related vulnerabilities, leading to high false positives. In this paper, we propose MVD, a statement-level <u>M</u>emory-related <u>V</u>ulnerability <u>D</u>etection approach based on flow-sensitive graph neural networks (FS-GNN). FS-GNN is employed to jointly embed both unstructured information (i.e., source code) and structured information (i.e., control- and data-flow) to capture implicit memory-related vulnerability patterns. We evaluate MVD on the dataset which contains 4,353 real-world memory-related vulnerabilities, and compare our approach with three state-of-the-art deep learning-based approaches as well as five popular static analysis-based memory detectors. The experiment results show that MVD achieves better detection accuracy, outperforming both state-of-the-art DL-based and static analysis-based approaches. Furthermore, MVD makes a great trade-off between accuracy and efficiency.",,
,ghaffarian2021neural,Java,Explore the utilization ofGraph Neural Networksas the latest trend and progress in the field of artificial neural networks.,Neural software vulnerability analysis using rich intermediate graph representations of programs,Others,Hybrid,"Path Traversal, Command Injection, Cross-Site Scripting, SQL Injection, LDAP Injection, Trust Boundary Violation, XPATH Injection",N.A,OWASP benchmark suit,CPG over files,Code,Source code,Graph,N.A,"TF-IDF, Doc2Vec, GCN, GAT",Hybrid,"CWE-22, CWE-78, CWE-89, CWE-90, CWE-501, CWE-643","scikit-learn, Networkx, GenSim, Keras/TensorFlow",DL,GNN,"GAT, GCN",Binary,No,"Security vulnerabilities are among the major concerns of modern software engineering. Successful results of machine learning techniques in various challenging applications have led to an emerging field of research to investigate the effectiveness of machine learning, and more recently, deep learning techniques, for the problem of software vulnerability analysis and discovery. In this paper, we explore the utilization of Graph Neural Networks as the latest trend and progress in the field of artificial neural networks. To this end, we propose an original neural vulnerability analysis approach, using customized intermediate graph representations of programs to train graph neural network models. Experimental results on a public suite of vulnerable programs show that the proposed approach is effective at the task of software vulnerability analysis. Additional empirical experiments answer complementary research questions about the proposed approach. In particular, we present experimental results for the challenging task of cross-project vulnerability analysis, with interesting insights on the capabilities of our novel approach. Furthermore, a software utility that was developed in the course of this study is also published as a further contribution to the research community.",,https://docs.google.com/document/d/16C_5jI615Zifr5ErOqhLrsCOYlEpEF-uhBSyg2iR6_s/edit?usp=sharing
,wu2021peculiar,Solidity,"SmartEmbed is such an approach, which uses a deep-learning model to determine whether the detected contract is vulnerable by calculating the similarity with the contracts in a bug However, its bug database is in limited scale, with only 52 known buggy smart contracts. Moreover, it performs bug detection at the statement level of granularity, without taking full advantage of the code structure and semantic information in smart contracts. Zhuang et al. construct a contract graph to represent both syntactic and semantic features of a smart contract function and using graph neural networks (GNNs) for smart contracts. However, we observe that the graph it uses is intricate for representing the program. It not only considers three types of nodes but also involves complex edge information.",Peculiar: Smart Contract Vulnerability Detection Based on Crucial Data Flow Graph and Pre-training Techniques,Semantic,Benchmark,N.A,N.A,Smartbugs Wild,CDFG over files,Code,Source code,Graph,N.A,GraphCodeBERT,Transformer Embedding,N.A,tree-sitter,DL,Transformers,GraphCodeBERT,Binary,No,"Smart contracts with natural economic attributes have been widely and rapidly developed in various fields. However, the bugs and vulnerabilities in smart contracts have brought huge economic losses, which has strengthened people's attention to the security issues of smart contracts. The immutability of smart contracts makes people more willing to conduct security checks before deploying smart contracts. Nonetheless, existing smart contract vulnerability detection techniques are far away from enough: static analysis approaches rely heavily on manually crafted heuristics which is difficult to reuse across different types of vulnerabilities while deep learning based approaches also have unique limitations. In this study, we propose a novel approach, Peculiar, which uses Pre-training technique for detection of smart contract vulnerabilities based on crucial data flow graph. Compared against the traditional data flow graph which is already utilized in existing approach, crucial data flow graph is less complex and does not bring an unnecessarily deep hierarchy, which makes the model easy to focus on the critical features. Moreover, we also involve pre-training technique in our model due to the dramatic improvements it has achieved on a variety of NLP tasks. Our empirical results show that Peculiar can achieve 91.80 % precision and 92.40 % recall in detecting reentrancy vulnerability, one of the most severe and common smart contract vulnerabilities, on 40,932 smart contract files, which is significantly better than the state-of-the-art methods (e.g., Smartcheck achieves 79.37% precision and 70.50% recall). Meanwhile, another experiment shows that Peculiar is more discerning to reentrancy vulnerability than existing approaches. The ablation experiment reveals that both crucial data flow graph and pre-trained model contribute significantly to the performances of Peculiar.",,
,scandariato2014predicting,Java,Investigate the potential of Text mining approaches to predict vulnerable sofware components,Predicting Vulnerable Software Components via Text Mining,Consider other data sources,Hybrid,"AnkiDroid, BoardGameGeek, Connectbot, CoolReader, Crosswords, FBReader, K9Mail, KeePassAndroid, MileageTracker, Mustard, Browser, Calender, Camera, Contacts, DeskClock, Dialer, Email, Gallery, Mms, QuickSearchBox",N.A,"F-Droid, Android IOS",files,Code,Source code,Token,N.A,Term Frequency,Others,N.A,N.A,ML,N.A,"Decision Trees, KNN, Naive Bayes, Random Forest, SVM",Binary,No,"This paper presents an approach based on machine learning to predict which components of a software application contain security vulnerabilities. The approach is based on text mining the source code of the components. Namely, each component is characterized as a series of terms contained in its source code, with the associated frequencies. These features are used to forecast whether each component is likely to contain vulnerabilities. In an exploratory validation with 20 Android applications, we discovered that a dependable prediction model can be built. Such model could be useful to prioritize the validation activities, e.g., to identify the components needing special scrutiny.",,https://docs.google.com/document/d/1ZaHly2Eg52LdpgHCxs5ZTyY2gyvZqkGf-MT6HlXgHiQ/edit?usp=sharing
,zhuang2020smart,Solidity,"existing methods heavily rely on several expert-defined hard rules (or patterns) to detect smart contract vulnerability. However, expert rules are error-prone and some complex patterns are non-trivial to be covered. Second, since the rules are contributed by a few ‘centralized’ experts who develop the detection tools, their scalability is inherently limited. As the number of smart contracts is increasing rapidly, it is impossible for a few experts to sift through all the contracts to design precise rules, while the knowledge of other ‘decentralized’ experts cannot be incorporated to improve the model",Smart Contract Vulnerability Detection Using Graph Neural Networks,Rely on expert rules,Benchmark,N.A,N.A,"ESC, VSC",Contract Graph over files,Code,Source code,Graph,N.A,DR-GCN,Graph embedding,N.A,N.A,DL,GNN,GCN ,Binary,No,"The security problems of smart contracts have drawn extensive attention due to the enormous financial losses caused by vulnerabilities. Existing methods on smart contract vulnerability detection heavily rely on fixed expert rules, leading to low detection accuracy. In this paper, we explore using graph neural networks (GNNs) for smart contract vulnerability detection. Particularly, we construct a contract graph to represent both syntactic and se-
mantic structures of a smart contract function. To highlight the major nodes, we design an elimination phase to normalize the graph. Then, we propose a degree-free graph convolutional neural network (DR-GCN) and a novel temporal message propaga- tion network (TMP) to learn from the normalized graphs for vulnerability detection. Extensive experiments show that our proposed approach significantly outperforms state-of-the-art methods in de-tecting three different types of vulnerabilities.",,
,li2017software,Java,"Modeling structural information in ASTs is important. For example, order of execution regarding API calls. ",Software Defect Prediction Via Convolutional Neural Networks,Semantic,Hybrid,"camel, jEdit, lucene, xalan, xerces, synapse, poi",N.A,PROMISE,AST over files,Code,Source code,Tree,N.A,Word2vec,Token vector embedding,N.A,"javalang, Keras/TensorFlow",DL,CNN,CNN,Binary,No,"To improve software reliability, software defect prediction is utilized to assist developers in finding potential bugs and allocating their testing efforts. Traditional defect prediction studies mainly focus on designing hand-crafted features, which are input into machine learning classifiers to identify defective code. However, these hand-crafted features often fail to capture the semantic and structural information of programs. Such information is important in modeling program functionality and can lead to more accurate defect prediction. In this paper, we propose a framework called Defect Prediction via Convolutional Neural Network (DP-CNN), which leverages deep learning for effective feature generation. Specifically, based on the programs' Abstract Syntax Trees (ASTs), we first extract token vectors, which are then encoded as numerical vectors via mapping and word embedding. We feed the numerical vectors into Convolutional Neural Network to automatically learn semantic and structural features of programs. After that, we combine the learned features with traditional hand-crafted features, for accurate software defect prediction. We evaluate our method on seven open source projects in terms of F-measure in defect prediction. The experimental results show that in average, DP-CNN improves the state-of-the-art method by 12%.",,
,lin2019software,C/C++,"The existing ML-based vulnerability/defect detection approaches, such as [18], [45], [53], have been constructed based on the assumption of the availability of sufficient labeled training data from the homogeneous sources.",Software Vulnerability Discovery via Learning Multi-Domain Knowledge Bases,Training data problem,Hybrid,"FFmpeg, LibTIFF, LibPNG, Pidgin, VLC media player, Asterisk",CVE,SARD,AST over functions,Code,Source code,Tree,N.A,Word2vec,Token vector embedding,"CWE-119, CWE-189","Keras/TensorFlow, scikit-learn, GenSim",DL,RNN,BiLSTM,Binary,No,"Machine learning (ML) has great potential in automated code vulnerability discovery. However, automated discovery application driven by off-the-shelf machine learning tools often performs poorly due to the shortage of high-quality training data. The scarceness of vulnerability data is almost always a problem for any developing software project during its early stages, which is referred to as the cold-start problem. This article proposes a framework that utilizes transferable knowledge from pre-existing data sources. In order to improve the detection performance, multiple vulnerability-relevant data sources were selected to form a broader base for learning transferable knowledge. The selected vulnerability-relevant data sources are cross-domain, including historical vulnerability data from different software projects and data from the Software Assurance Reference Database (SARD) consisting of synthetic vulnerability examples and proof-of-concept test cases. To extract the information applicable in vulnerability detection from the cross-domain data sets, we designed a deep-learning-based framework with Long-short Term Memory (LSTM) cells. Our framework combines the heterogeneous data sources to learn unified representations of the patterns of the vulnerable source codes. Empirical studies showed that the unified representations generated by the proposed deep learning networks are feasible and effective, and are transferable for real-world vulnerability detection. Our experiments demonstrated that by leveraging two heterogeneous data sources, the performance of our vulnerability detection outperformed the static vulnerability discovery tool Flawfinder . The findings of this article may stimulate further research in ML-based vulnerability detection using heterogeneous data sources.",,https://docs.google.com/document/d/1CDKBPuXkLugkauRm27vhp5ug2ilO_p-1XxcJdEplTuc/edit?usp=sharing
,li2021sysevr,C/C++,How can we represent programs as vectors that accommodate the syntax and semantic information that is suitable for vulnerability detection?,SySeVR A framework for using deep learning to detect software vulnerabilities,Semantic,Benchmark,N.A,N.A,"NVD, SARD",Simplified Property Graph (SPG),Code,Source code,Graph,N.A,Word2vec,Token vector embedding,N.A,Keras/TensorFlow,DL,RNN,BGRU,Binary,No,"The detection of software vulnerabilities (or vulnerabilities for short) is an important problem that has yet to be tackled, as manifested by the many vulnerabilities reported on a daily basis. This calls for machine learning methods for vulnerability detection. Deep learning is attractive for this purpose because it alleviates the requirement to manually define features. Despite the tremendous success of deep learning in other application domains, its applicability to vulnerability detection is not systematically understood. In order to fill this void, we propose the first systematic framework for using deep learning to detect vulnerabilities in C/C++ programs with source code. The framework, dubbed Syntax-based, Semantics-based, and Vector Representations (SySeVR), focuses on obtaining program representations that can accommodate syntax and semantic information pertinent to vulnerabilities. Our experiments with four software products demonstrate the usefulness of the framework: we detect 15 vulnerabilities that are not reported in the National Vulnerability Database. Among these 15 vulnerabilities, seven are unknown and have been reported to the vendors, and the other eight have been “silently” patched by the vendors when releasing newer versions of the pertinent software products.",,https://docs.google.com/document/d/1BBcZw2kWxy8_2VeFoVIPTQRwCw_1gP4qJ7cq7ptJL-w/edit?usp=sharing
,filus2020random,C/C++,Other,The random neural network as a bonding model for software vulnerability prediction,Others,Benchmark,N.A,N.A,"NVD, SARD",functions,Code,Source code,Token,N.A,Word2vec,Token vector embedding,"CWE-119, CWE-399",Keras/TensorFlow,DL,Hybrid,"CNN, RNN",Binary,No,"Software vulnerability prediction is an important and active area of research where new methods are needed to build accurate and efficient tools that can identify security issues. Thus we propose an approach based on mixed features that combines text mining features and the features generated using a Static Code Analyzer. We use a Random Neural Network as a bonding model that combines the text analysis that is carried out on software using a Convolutional Neural Network, and the outputs of Static Code Analysis. The proposed approach was evaluated on commonly used datasets and led to 97% training accuracy, and 93%–94% testing accuracy, with a 1% reduction in false positives with respect to previously published results on similar data sets.",,
,riom2021revisiting,*,"Metra data information is neglected. Considering features extracted from repositories separately to together. Source codes are not prioritized according to their vulnerabilities. Features only extracted from source codes are not enough, metadata information also required.",VCCFinder: Finding Potential Vulnerabilities in Open-Source Projects to Assist Code Audits,Consider other data sources,Repository,N.A,"CVE, GitHub",N.A,Commits files characteristics,Numerical,Commit Metrics,Commit Metrics,N.A,"Word2vec, commit metrics",Others,N.A,LibLinear,ML,N.A,SVM,Binary,No,"Despite the security community's best effort, the number of serious vulnerabilities discovered in software is increasing rapidly. In theory, security audits should find and remove the vulnerabilities before the code ever gets deployed. However, due to the enormous amount of code being produced, as well as a the lack of manpower and expertise, not all code is sufficiently audited. Thus, many vulnerabilities slip into production systems. A best-practice approach is to use a code metric analysis tool, such as Flawfinder, to flag potentially dangerous code so that it can receive special attention. However, because these tools have a very high false-positive rate, the manual effort needed to find vulnerabilities remains overwhelming. In this paper, we present a new method of finding potentially dangerous code in code repositories with a significantly lower false-positive rate than comparable systems. We combine code-metric analysis with metadata gathered from code repositories to help code review teams prioritize their work. The paper makes three contributions. First, we conducted the first large-scale mapping of CVEs to GitHub commits in order to create a vulnerable commit database. Second, based on this database, we trained a SVM classifier to flag suspicious commits. Compared to Flawfinder, our approach reduces the amount of false alarms by over 99 % at the same level of recall. Finally, we present a thorough quantitative and qualitative analysis of our approach and discuss lessons learned from the results. We will share the database as a benchmark for future research and will also provide our analysis tool as a web service.",,https://docs.google.com/document/d/12_J7x8AI-AguIaviydRosgn-yKs5Rj4hmwclZN41_f8/edit?usp=sharing
,li2021vuldeelocator,C/C++,"Capturing the relations between semantically-related statements across program, Accommodating accurate control flows and variable define-use relations, We observe that although they operate on program slices (which are fine-grained than functions), a program slice can have many lines of code.",Vuldeelocator a deep learning based fine grained vulnerability detector,Semantic,Hybrid,"Linux Kernel, OpenSSL, FFmpeg, Wireshark, Libtiff",N.A,"NVD, SARD",AST over functions,Code,Source code,Tree,N.A,Word2vec,Token vector embedding,"CWE-127, CWE-78",Keras/TensorFlow,DL,RNN,"BiLSTM, BGRU",Binary,Yes," Automatically detecting software vulnerabilities is an important problem that has attracted much attention from the academic research community. However, existing vulnerability detectors still cannot achieve the vulnerability detection capability and the locating precision that would warrant their adoption for real-world use. In this paper, we present a vulnerability detector that can simultaneously achieve a high detection capability and a high locating precision, dubbed Vulnerability Deep learning-based Locator (VulDeeLocator). In the course of designing VulDeeLocator, we encounter difficulties including how to accommodate semantic relations between the definitions of types as well as macros and their uses across files, how to accommodate accurate control flows and variable define-use relations, and how to achieve high locating precision. We solve these difficulties by using two innovative ideas: (i) leveraging intermediate code to accommodate extra semantic information, and (ii) using the notion of granularity refinement to pin down locations of vulnerabilities. When applied to 200 files randomly selected from three real-world software products, VulDeeLocator detects 18 confirmed vulnerabilities (i.e., true-positives). Among them, 16 vulnerabilities correspond to known vulnerabilities; the other two are not reported in the National Vulnerability Database (NVD) but have been ""silently"" patched by the vendor of Libav when releasing newer versions. ",,https://docs.google.com/document/d/1ywCDNuZUJUpptLmAkcnw_AhJ-idinwnS-9OKW_1NkN4/edit
,li2018vuldeepecker,C/C++,"Manual design of features and high false positive rate. Given the source code of a target program, how can we determine whether or not the target program is vulnerable and if so, where are the vulnerabilities",Vuldeepecker A deep learning based system for vulnerability detection,High false positive of static analyzers,Benchmark,N.A,N.A,"NVD, SARD",code gadgets over functions,Code,Source code,Graph,N.A,Word2vec,Token vector embedding,"CWE-119, CWE-399","Theano, Keras/TensorFlow",DL,RNN,BiLSTM,Binary,No,"The automatic detection of software vulnerabilities is an important research problem. However, existing solutions to this problem rely on human experts to define features and often miss many vulnerabilities (i.e., incurring high false negative rate). In this paper, we initiate the study of using deep learning-based vulnerability detection to relieve human experts from the tedious and subjective task of manually defining features. Since deep learning is motivated to deal with problems that are very different from the problem of vulnerability detection, we need some guiding principles for applying deep learning to vulnerability detection. In particular, we need to find representations of software programs that are suitable for deep learning. For this purpose, we propose using code gadgets to represent programs and then transform them into vectors, where a code gadget is a number of (not necessarily consecutive) lines of code that are semantically related to each other. This leads to the design and implementation of a deep learning-based vulnerability detection system, called Vulnerability Deep Pecker (VulDeePecker). In order to evaluate VulDeePecker, we present the first vulnerability dataset for deep learning approaches. Experimental results show that VulDeePecker can achieve much fewer false negatives (with reasonable false positives) than other approaches. We further apply VulDeePecker to 3 software products (namely Xen, Seamonkey, and Libav) and detect 4 vulnerabilities, which are not reported in the National Vulnerability Database but were ""silently"" patched by the vendors when releasing later versions of these products; in contrast, these vulnerabilities are almost entirely missed by the other vulnerability detection systems we experimented with. ",,https://docs.google.com/document/d/1T6ga18o_7C38bGIQkL2xFL_X_cKABmgfEs63zmP6mzo/edit
,Vuldiggerpaper,C/C++,"1) The lack of a ground-truth dataset 2) Code changes could not retain the original structure and integrity like files or components, hence many established measures (e.g., code complexity, coupling, and cohesion) and commercial analysis tools (e.g., Understand C++) are not directly applicable",Vuldigger: a just-in-time and cost-aware tool for digging vulnerability-contributing changes,Training data problem,Hybrid,N.A,Bugzilla,"MFSA, Firefox",Commits files characteristics,Numerical,Commit Metrics,Commit Metrics,N.A,commit metrics,Others,N.A,N.A,ML,N.A,Random Forest,Binary,No,"It has been widely adopted to minimize the maintenance cost by predicting potential vulnerabilities before code audits in academia and industry. Most previous research dedicated to file/component level vulnerability prediction models is coarse- grained and may suffer from cost-prohibitive and impractical security testing activities. In this paper, we focus on a cost- aware vulnerability prediction model and present a just-in-time change-level code review tool called VulDigger to dig suspicious ones from a sea of code changes. Our contributions benefit from the case study of Mozilla Firefox by constructing a large-scale vulnerability-contributing changes (VCCs) dataset in a semi-automatic fashion. We then further manifest a classification tool with a mixture of established and new metrics derived from both software defect prediction and vulnerability prediction. Consequently, the precision of such tool is extremely promising (i.e., 92%) for an effort-aware software team. We also examine the return on investment by training a regression model to locate most skeptical changes with fewer lines to inspect. Our findings suggest that such model is capable of pinpointing 31% of all VCCs with only 20% of the effort it would take to audit all changes (i.e., 55% better than random predictor). Our outputs can assist as an early step of continuous security inspections as it provides immediate feedback once developers submit changes to their code base.",,
,li2021vulnerability,C/C++,"Despite several advantages, the ML/DL-based VD approaches are still limited to providing only coarse-grained detection results  on whether an entire given method is vulnerable or not. In comparison with the PA-based approaches, they fall short in the ability to elaborate on the fine-grained details of the lines of code with specific statements that might be involved in the detected vulnerability. ",vulnerability detection with fine grained interpretations,Granularity,Hybrid,"FFMPeg, Qemu",N.A,"Fan et al, Reveal",PDG over functions,Code,Source code,Graph,Graph+Tree+Token,"GloVe, GRU, Tree-LSTM",Token vector embedding,N.A,N.A,DL,Hybrid,"GCN, GRU, Tree-LSTM",interperetable,yes,"Despite the successes of machine learning (ML) and deep learning (DL)-based vulnerability detectors (VD), they are limited to providing only the decision on whether a given code is vulnerable or not, without details on what part of the code is relevant to the detected vulnerability. We present IVDetect, an interpretable vulnerability detector with the philosophy of using Artificial Intelligence (AI) to detect vulnerabilities, while using Intelligence Assistant (IA) to provide VD interpretations in terms of vulnerable statements.For vulnerability detection, we separately consider the vulnerable statements and their surrounding contexts via data and control dependencies. This allows our model better discriminate vulnerable statements than using the mixture of vulnerable code and contextual code as in existing approaches. In addition to the coarse-grained vulnerability detection result, we leverage interpretable AI to provide users with fine-grained interpretations that include the sub-graph in the Program Dependency Graph (PDG) with the crucial statements that are relevant to the detected vulnerability. Our empirical evaluation on vulnerability databases shows that IVDetect outperforms the existing DL-based approaches by 43%–84% and 105%–255% in top-10 nDCG and MAP ranking scores. IVDetect correctly points out the vulnerable statements relevant to the vulnerability via its interpretation in 67% of the cases with a top-5 ranked list. IVDetect improves over the baseline interpretation models by 12.3%–400% and 9%–400% in accuracy.",,https://docs.google.com/document/d/1_8CdioLGKq_XzAQaDj1nye1shZFzcJF1a3Vy-qlZc6U/edit?usp=sharing
,yamaguchi2011vulnerability,C/C++,"Instead of struggling with the limitations of automatic analysis, the proposed method aims at rendering manual auditing more effective by assisting and guiding the inspection of source code.",Vulnerability Extrapolation: Assisted Discovery of Vulnerabilities using Machine Learning,Others,Open Source Projects,"FFmpeg, Linux Kernel",N.A,N.A,functions,Code,Source code,Token,N.A,TF-IDF,Others,N.A,N.A,ML,N.A,PCA,Vulnerability Extrapolation,no,"Rigorous identification of vulnerabilities in program code is a key to implementing and operating secure systems. Unfortunately, only some types of vulnerabilities can be detected automatically. While techniques from software testing can accelerate the search for security flaws, in the general case discovery of vulnerabilities is a tedious process that requires significant expertise and time. In this paper, we propose a method for assisted discovery of vulnerabilities in source code. Our method proceeds by embedding code in a vector space and automatically determining API usage patterns using machine learning. Starting from a known vulnerability, these patterns can be exploited to guide the auditing of code and to identify potentially vulnerable code with similar characteristics--a process we refer to as vulnerability extrapolation. We empirically demonstrate the capabilities of our method in different experiments. In a case study with the library FFmpeg, we are able to narrowthe search for interesting code from 6,778 to 20 functions and discover two security flaws, one being a known flaw and the other constituting a zero-day vulnerability.",,https://docs.google.com/document/d/1-eFPGgjJ-3l5XahXgzbGDlzN87qoy3Xda927fndUj1E/edit?usp=sharing
,duan2019vulsniper,C/C++,Considering semantic information of functions by using CPGs,VulSniper focus your attention to shoot fine grained vulnerabilities,Semantic,Benchmark,N.A,N.A,SARD,CPG over functions,Code,Source code,Graph,N.A,adjacency matrix,Graph embedding,"CWE-119, CWE-399",N.A,DL,Attention Mechanism,Attention Mechanism,Binary,No,"With the explosive development of information technology, vulnerabilities have become one of the major threats to computer security. Most vulnerabilities with similar patterns can be detected effectively by static analysis methods. However, some vulnerable and non-vulnerable code is hardly distinguishable, resulting in low detection accuracy. In this paper, we define the accurate identification of vulnerabilities in similar code as a fine-grained vulnerability detection problem. We propose Vul-Sniper which is designed to detect fine-grained vulnerabilities more effectively. In VulSniper, attention mechanism is used to capture the critical features of the vulnerabilities. Especially, we use bottom-up and top-down structures to learn the attention weights of different areas of the program. Moreover, in order to fully extract the semantic features of the program, we generate the code property graph, design a 144-dimensional vector to describe the relation between the nodes, and finally encode the program as a feature tensor. VulSniper achieves F1-scores of 80.6% and 73.3% on the two benchmark datasets, the SARD Buffer Error dataset and the SARD Resource Management Error dataset respectively, which are significantly higher than those of the state-of-the-art methods.",,https://docs.google.com/document/d/13r2Ld5R7-ELmXG5g2ZDgGGhjCQnlop3VW3U2LbD_thE/edit?usp=sharing
,zheng2021vulspg,C/C++,"Covering more corner cases by considering more SeVCs (slicing criteria) compred to SySeVR, Considering graph based embedding compared to SySeVr which only consider token based embedding",VulSPG: Vulnerability detection based on slice property graph representation learning,Semantic,Hybrid,"FFMPeg, Qemu",N.A,"NVD, SARD",SPG over functions,Code,Source code,Graph,N.A,"word2vec, R-GCN",Hybrid,N.A,PyTorch,DL,GNN,GCN,Binary,No,"Vulnerability detection is an important issue in software security. Although various data-driven vulnerability detection methods have been proposed, the task remains challenging since the diversity and complexity of real-world vulnerable code in syntax and semantics make it difficult to extract vulnerable features with regular deep learning models, especially in analyzing a large program. Moreover, the fact that real-world vulnerable codes contain a lot of redundant information unrelated to vulnerabilities will further aggravate the above problem. To mitigate such challenges, we define a novel code representation named Slice Property Graph (SPG), and then propose VulSPG, a new vulnerability detection approach using the improved R-GCN model with triple attention mechanism to identify potential vulnerabilities in SPG. Our approach has at least two advantages over other methods. First, our proposed SPG can reflect the rich semantics and explicit structural information that may be relevance to vulnerabilities, while eliminating as much irrelevant information as possible to reduce the complexity of graph. Second, VulSPG incorporates triple attention mechanism in R-GCNs to achieve more effective learning of vulnerability patterns from SPG. We have extensively evaluated VulSPG on two large-scale datasets with programs from SARD and real-world projects. Experimental results prove the effectiveness and efficiency of VulSPG. ",,https://docs.google.com/document/d/1wnOqvAyPnxxHQj6c_ZXDC6fBkqSBVXLoJchNOf-lsW0/edit?usp=sharing
,zhuang2022just,Java,"However, how to extract semantic information from broken changing code snippets is still a challenging problem",Just-in-time defect prediction based on AST change embedding,Semantic,Open Source Projects,"ambari, ant, aptoide, camel, cassandra, egeria, felix, jackrabbit, lucene",N.A,N.A,AST over files,Code,Source code,Tree,N.A,"GloVe, AST change embedding",Hybrid,N.A,Keras/TensorFlow,DL,RNN,LSTM,Binary,No,"Just-in-time (JIT) defect prediction can help developers quickly identify whether a change is defective or not. The features extracted from changes play an essential role in building an accurate prediction model. In recent years, it has been considered effective to extract the semantic features of software code files by using code representation technology. However, how to extract semantic information from broken changing code snippets is still a challenging problem. We propose a new feature to represent code semantics based on Abstract Syntax Trees (ASTs), called ACE (AST Change Embedding), by comparing the abstract syntax tree of source code before and after a change and extracting AST change sequences, and then mapping them into numeric vectors by using word embedding technology. At the same time, we utilize the gated mechanism to build a gated hierarchical model, called GH-ACE, to combine the traditional manual features and semantic features. We conduct experiments on within-project and cross-project defect prediction tasks and evaluate the effectiveness of our proposed model in non-effort-aware scenarios and effort-aware scenarios. The results show that, on average, our model is 4.0 percent higher than the best baseline method for within-project defect prediction and 2.4 percent higher than the best baseline method for cross-project defect prediction.",,
,cheng2022path,C/C++,"However, these models are still insufficient for precise bug detection, because the objective of these models is to produce classification results rather than comprehending the semantics of vulnerabilities, e.g., pinpoint bugtriggering paths, which are essential for static bug detection.",Path-Sensitive Code Embedding via Contrastive Learning for Software Vulnerability Detection,Semantic,Hybrid,"FFMPeg, Qemu",N.A,"D2A, Fan et al",AST over files,Code,Source code,Tree,N.A,Value-flow Path Encoding,Graph embedding,N.A,"PyTorch, Joern, Clang, Z3 SMT solver",DL,Attention Mechanism,Attention Mechanism,Binary,No,"Machine learning and its promising branch deep learning have shown success in a wide range of application domains. Recently, much effort has been expended on applying deep learning techniques (e.g., graph neural networks) to static vulnerability detection as an alternative to conventional bug detection methods. To obtain the structural information of code, current learning approaches typically abstract a program in the form of graphs (e.g., data-flow graphs, abstract syntax trees), and then train an underlying classification model based on the (sub)graphs of safe and vulnerable code fragments for vulnerability prediction. However, these models are still insufficient for precise bug detection, because the objective of these models is to produce classification results rather than comprehending the semantics of vulnerabilities, e.g., pinpoint bug triggering paths, which are essential for static bug detection. This paper presents ContraFlow, a selective yet precise contrastive value-flow embedding approach to statically detect software vulnerabilities. The novelty of ContraFlow lies in selecting and preserving feasible value-flow (aka program dependence) paths through a pretrained path embedding model using self-supervised contrastive learning, thus significantly reducing the amount of labeled data required for training expensive downstream models for path-based vulnerability detection. We evaluated ContraFlow using 288 real-world projects by comparing eight recent learning-based approaches. ContraFlow outperforms these eight baselines by up to 334.1%, 317.9%, 58.3% for informedness, markedness and F1 Score, and achieves up to 450.0%, 192.3%, 450.0% improvement for mean statement recall, mean statement precision and mean IoU respectively in terms of locating buggy statements.",,
,liu2021smart,Solidity,"This motivates us to consider whetherwe could combine neural networks with classical expert patterns, where neural networks contribute their ability to handle the complex code semantic graph while expert patterns contribute precise and valuable local information.",Smart Contract Vulnerability Detection: From Pure Neural Network to Interpretable Graph Feature and Expert Pattern Fusion,Semantic,Benchmark,N.A,N.A,"ESC, VSC","CFG, DFG over files",Code,Source code,Graph,N.A,graph embedding,Graph embedding,N.A,Keras/TensorFlow,DL,Attention Mechanism,Attention Mechanism,Binary,Yes,"Smart contracts hold digital coins worth billions of dollars, their security issues have drawn extensive attention in the past years. Towards smart contract vulnerability detection, conventional methods heavily rely on fixed expert rules, leading to low accuracy and poor scalability. Recent deep learning approaches alleviate this issue but fail to encode useful expert knowledge. In this paper, we explore combining deep learning with expert patterns in an explainable fashion. Specifically, we develop automatic tools to extract expert patterns from the source code. We then cast the code into a semantic graph to extract deep graph features. Thereafter, the global graph feature and local expert patterns are fused to cooperate and approach the final prediction, while yielding their interpretable weights. Experiments are conducted on all available smart contracts with source code in two platforms, Ethereum and VNT Chain. Empirically, our system significantly outperforms state-of-the-art methods. Our code is released. ",,
,ding2022velvet,C/C++,"Thus, developers still need to inspect a significant amount of code to locate the vulnerable statement(s) that need to be fixed",VELVET: a noVel Ensemble Learning approach to automatically locate VulnErable sTatements,Granularity,Benchmark,N.A,N.A,"Juliet Test Suit, D2A",CPG over files,Code,Source code,Graph,N.A,Word2vec,Token vector embedding,"CWE-190, CWE-119, CWE-476, CWE-401, CWE-563, CWE-369, CWE-457, CWE-416","Keras/TensorFlow, Joern",DL,GNN,GGNN,Binary,No,"Automatically locating vulnerable statements in source code is crucial to assure software security and alleviate developers' debugging efforts. This becomes even more important in today's software ecosystem, where vulnerable code can flow easily and unwittingly within and across software repositories like GitHub. Across such millions of lines of code, traditional static and dynamic approaches struggle to scale. Although existing machine-learning-based approaches look promising in such a setting, most work detects vulnerable code at a higher granularity – at the method or file level. Thus, developers still need to inspect a significant amount of code to locate the vulnerable statement(s) that need to be fixed. This paper presents Velvet, a novel ensemble learning approach to locate vulnerable statements. Our model combines graph-based and sequence-based neural networks to successfully capture the local and global context of a program graph and effectively understand code semantics and vulnerable patterns. To study Velvet's effectiveness, we use an off-the-shelf synthetic dataset and a recently published real-world dataset. In the static analysis setting, where vulnerable functions are not detected in advance, Velvet achieves 4.5× better performance than the baseline static analyzers on the real-world data. For the isolated vulnerability localization task, where we assume the vulnerability of a function is known while the specific vulnerable statement is unknown, we compare Velvet with several neural networks that also attend to local and global context of code. Velvet achieves 99.6% and 43.6% top-1 accuracy over synthetic data and real-world data, respectively, outperforming the baseline deep learning models by 5.3-29.0%.",,
,zhang2022reentrancy,Solidity,Reentrancy problem,Reentrancy Vulnerability Detection and Localization: A Deep Learning Based Two-phase Approach,Reentrancy,Benchmark,N.A,N.A,Smartbugs Wild,AST over functions,Code,Source code,Tree,N.A,GraphCodeBERT,Graph embedding,N.A,N.A,DL,Attention Mechanism,Attention Mechanism,ranking,no,"Smart contracts have been widely and rapidly used to automate financial and business transactions together with blockchains, helping people make agreements while minimizing trusts. With millions of smart contracts deployed on blockchain, various bugs and vulnerabilities in smart contracts have emerged. Following the rapid development of deep learning, many recent studies have used deep learning for vulnerability detection to conduct security checks before deploying smart contracts. These approaches show effective results on detecting whether a smart contract is vulnerable or not whereas their results on locating suspicious statements responsible for the detected vulnerability are still unsatisfactory. To address this problem, we propose a deep learning based two-phase smart contract debugger for reentrancy vulnerability, one of the most severe vulnerabilities, named as ReVulDL: Reentrancy Vulnerability Detection and Localization. ReVulDL integrates the vulnerability detection and localization into a unified debugging pipeline. For the detection phase, given a smart contract, ReVulDL uses a graph-based pre-training model to learn the complex relationships in propagation chains for detecting whether the smart contract contains a reentrancy vulnerability. For the localization phase, if a reentrancy vulnerability is detected, ReVulDL utilizes interpretable machine learning to locate the suspicious statements in smart contract to provide interpretations of the detected vulnerability. Our large-scale empirical study on 47,398 smart contracts shows that ReVulDL achieves promising results in detecting reentrancy vulnerabilities (e.g., outperforming 16 state-of-the-art vulnerability detection approaches) and locating vulnerable statements (e.g., 70.38% of the vulnerable statements are ranked within Top-10).",,
,ni2022best,Java,"Low-quality datasets, Independently mined features, Independently built models",The Best of Both Worlds: Integrating Semantic Features with Expert Features for Defect Prediction and Localization,Training data problem,Hybrid,"ant-ivy, commons-bcel, commons-beanutil, commons-codec, commons-collections, commons-compress, commons-configuration, commons-dbcp, commons-digester, commons-io, commons-jcs, commons-lang, commons-math, commons-net, commons-scxml, commons-validator, commons-vfs, giraph, gora, opennlp, parquet-mr",GitHub,N.A,Commit,Numerical,Commit Metrics,Commit Metrics,,"commit metrics, codeBERT",Hybrid,N.A,N.A,DL,Transformers,CodeBERT,Binary,No,"To improve software quality, just-in-time defect prediction (JIT-DP) (identifying defect-inducing commits) and just-in-time defect localization (JIT-DL) (identifying defect-inducing code lines in commits) have been widely studied by learning semantic features or expert features respectively, and indeed achieved promising performance. Semantic features and expert features describe code change commits from different aspects, however, the best of the two features have not been fully explored together to boost the just-in-time defect prediction and localization in the literature yet. Additional, JIT-DP identifies defects at the coarse commit level, while as the consequent task of JIT-DP, JIT-DL cannot achieve the accurate localization of defect-inducing code lines in a commit without JIT-DP. We hypothesize that the two JIT tasks can be combined together to boost the accurate prediction and localization of defect-inducing commits by integrating semantic features with expert features. Therefore, we propose to build a unified model, JIT-Fine, for the just-in-time defect prediction and localization by leveraging the best of semantic features and expert features. To assess the feasibility of JIT-Fine, we first build a large-scale line-level manually labeled dataset, JIT-Defects4J. Then, we make a comprehensive comparison with six state-of-the-art baselines under various settings using ten performance measures grouped into two types: effort-agnostic and effort-aware. The experimental results indicate that JIT-Fine can outperform all state-of-the-art baselines on both JIT-DP and JITDL tasks in terms of ten performance measures with a substantial improvement (i.e., 10%-629% in terms of effort-agnostic measures on JIT-DP, 5%-54% in terms of effort-aware measures on JIT-DP, and 4%-117% in terms of effort-aware measures on JIT-DL).",,
,yang2022source,C/C++,,Source Code Vulnerability Detection Using Vulnerability Dependency Representation Graph,Semantic,Benchmark,N.A,N.A,SARD,vulnerability control dependency edge,Code,Source code,Graph,N.A,HGT,Graph embedding,"CWE-20,CWE-78,CWE-129,CWE-190,CWE-400,CWE-787,CWE-789",N.A,DL,Transformers,HGT,Binary,No,"Aiming at the fact that the existing source code vulnerability detection methods did not explicitly maintain the semantic information related to the vulnerability in the source code, which made it difficult for the vulnerability detection model to extract the vulnerability sentence features and had a high detection false positive rate, a source code vulnerability detection method based on the vulnerability dependency graph is proposed. Firstly, the candidate vulnerability sentences of the function were matched, and the vulnerability dependency representation graph corresponding to the function was generated by analyzing the multi-layer control dependencies and data dependencies of the candidate vulnerability sentences. Secondly, abstracted the function name and variable name of the code sentences node and generated the initial representation vector of the code sentence nodes in the vulnerability dependency representation graph. Finally, the source code vulnerability detection model based on the heterogeneous graph transformer was used to learn the context information of the code sentence nodes in the vulnerability dependency representation graph. In this paper, the proposed method was verified on three datasets. The experimental results show that the proposed method have better performance in source code vulnerability detection, and the recall rate is increased by 1.50%~22.27%, and the F1 score is increased by 1.86%~16.69%, which is better than the existing methods.",,
,zou2022mvulpreter,C/C++,,mVulPreter: A Multi-granularity Vulnerability Detection System with Interpretations,Granularity,Hybrid,"Libav, Xen, Openssl, Thunderbird",N.A,Big-Vul,PDG over functions,Code,Source code,Graph,N.A,GGNN,Graph embedding,N.A,"Joern, sent2vec, PyTorch",DL,GNN,GGNN,Binary,No,"Due to the powerful automatic feature extraction, deep learning-based vulnerability detection methods have evolved significantly in recent years. However, almost all current work focuses on detecting vulnerabilities at a single granularity (i.e., slice-level or function-level). In practice, slice-level vulnerability detection is fine-grained but may contain incomplete vulnerability details. Function-level vulnerability detection includes full vulnerability semantics but may contain vulnerability-unrelated statements. Meanwhile, they pay more attention to predicting whether the source code is vulnerable and cannot pinpoint which statements are more likely to be vulnerable. In this paper, we design mVulPreter, a multi-granularity vulnerability detector that can provide interpretations of detection results. Specifically, we propose a novel technique to effectively blend the advantages of function-level and slice-level vulnerability detection models and output the detection results' interpretation only by the model itself. We evaluate mVulPreter on a dataset containing 5,310 vulnerable functions and 7,601 non-vulnerable functions. The experimental results indicate that mVulPreter outperforms existing state-of-the-art vulnerability detection approaches (i.e., Checkmarx, FlawFinder, RATS, TokenCNN, StatementLSTM, SySeVR, and Devign).",,
,nguyen2022mando,Solidity,,MANDO: Multi-Level Heterogeneous Graph Embeddings for Fine-Grained Detection of Smart Contract Vulnerabilities,Semantic,Benchmark,N.A,N.A,"Smartbugs Wild, SolidiFi",contract graph,Code,Source code,Graph,N.A,"node2vec, GCN",Hybrid,N.A,N.A,DL,GNN,GCN,Multi label,Yes,"Learning heterogeneous graphs consisting of different types of nodes and edges enhances the results of homogeneous graph techniques. An interesting example of such graphs is control-flow graphs representing possible software code execution flows. As such graphs represent more semantic information of code, developing techniques and tools for such graphs can be highly beneficial for detecting vulnerabilities in software for its reliability. However, existing heterogeneous graph techniques are still insufficient in handling complex graphs where the number of different types of nodes and edges is large and variable. This paper concentrates on the Ethereum smart contracts as a sample of software codes represented by heterogeneous contract graphs built upon both control-flow graphs and call graphs containing different types of nodes and links. We propose MANDO, a new heterogeneous graph representation to learn such heterogeneous contract graphs' structures. MANDO extracts customized metapaths, which compose relational connections between different types of nodes and their neighbors. Moreover, it develops a multi-metapath heterogeneous graph attention network to learn multi-level embeddings of different types of nodes and their metapaths in the heterogeneous contract graphs, which can capture the code semantics of smart contracts more accurately and facilitate both fine-grained line-level and coarse-grained contract-level vulnerability detection. Our extensive evaluation of large smart contract datasets shows that MANDO improves the vulnerability detection results of other techniques at the coarse-grained contract level. More importantly, it is the first learning-based approach capable of identifying vulnerabilities at the fine-grained line-level, and significantly improves the traditional code analysis-based vulnerability detection approaches by 11.35% to 70.81% in terms of F1-score. ",,
,nguyen2022mando2,Solidity,,MANDO-GURU: vulnerability detection for smart contract source code by heterogeneous graph embeddings,Semantic,Benchmark,N.A,N.A,"Smartbugs Wild, SolidiFi",contract graph,Code,Source code,Graph,N.A,node2vec,Token vector embedding,N.A,N.A,DL,GNN,HGNN,Multi label,Yes,"Smart contracts are increasingly used with blockchain systems for high-value applications. It is highly desired to ensure the quality of smart contract source code before they are deployed. This paper proposes a new deep learning-based tool, MANDO-GURU, that aims to accurately detect vulnerabilities in smart contracts at both coarse-grained contract-level and fine-grained line-level. Using a combination of control-flow graphs and call graphs of Solidity code, we design new heterogeneous graph attention neural networks to encode more structural and potentially semantic relations among different types of nodes and edges of such graphs and use the encoded embeddings of the graphs and nodes to detect vulnerabilities. Our validation of real-world smart contract datasets shows that MANDO-GURU can significantly improve many other vulnerability detection techniques by up to 24% in terms of the F1-score at the contract level, depending on vulnerability types. It is the first learning-based tool for Ethereum smart contracts that identify vulnerabilities at the line level and significantly improves the traditional code analysis-based techniques by up to 63.4%. Our tool is publicly available at https://github.com/MANDO-Project/ge-sc-machine. A test version is currently deployed at http://mandoguru.com, and a demo video of our tool is available at http://mandoguru.com/demo-video.",,
1,du2020cross,,,Cross-project bug type prediction based on transfer learning,Training data problem,Hybrid,"Linux Kernel, MySQL, HTTPD, AXIS",N.A,Xiao et al. ,bug reports,text,text,Token,N.A,"Word2vec, bit vector",Hybrid,N.A,scikit-learn,ML,N.A,"Gradient Boosting, SGDClassifier, AdaBoost, TrAdaBoost",Binary,No,,,
,steenhoek2024dataflow,,,Dataflow Analysis-Inspired Deep Learning for Efficient Vulnerability Detection,Semantic,Benchmark,N.A,N.A,"DbgBench, Big-Vul",CFG over functions,Code,Source code,Graph,N.A,"bit vector, GGNN",Hybrid,N.A,"Joern, PyTorch, DGL",DL,GNN,GGNN,Binary,No,,,
,li2023vulanalyzer,,,VulANalyzeR: Explainable Binary Vulnerability Detection with Multi-task Learning and Attentional Graph Convolution,Semantic,Hybrid,N.A,CVE,"NDSS, Juliet Test Suit",CFG over files,Code,Binary code,Graph,N.A,"BiGRU, GCN",Graph embedding,"CWE-119, CWE-399, CWE-78, ",N.A,DL,Hybrid,"BGRU, GCN",Binary,Yes,,,
1,sendner2023smarter,Solidity,,Smarter Contracts: Detecting Vulnerabilities in Smart Contracts with Deep Transfer Learning,New vulnerabilities,Repository,N.A,Etherscan,N.A,files,Code,Binary code,Token,N.A,word embedding,Token vector embedding,"Callstack Depth, Money Concurrency, Assert Violation, Reentrancy, Unchecked Call, Time Dependenc, DoS with Failed Call, CWE-190, CWE-191",Keras/TensorFlow,DL,RNN,"LSTM, GRU",Binary,No,,,
,nguyen2024deep,,,Deep Domain Adaptation With Max-Margin Principle for Cross-Project Imbalanced Sotware Vulnerability Detection,Training data problem,Open Source Projects,"FFmpeg, LibTIFF, LibPNG, VLC, Pidgin",N.A,N.A,functions,Code,Source code,Token,N.A,Token vector embedding,Token vector embedding,N.A,Keras/TensorFlow,DL,Hybrid,"BRNN, GAN",Binary,No,,,
,sun2021vdsimilar,,,VDSimilar: Vulnerability detection based on code similarity of vulnerabilities and patches,Semantic,Hybrid,"OpenSSL, Linux Kernel",CVE,N.A,functions,Code,Source code,Token,N.A,Token vector embedding,Token vector embedding,"CWE-772, CWE-476, CWE-416, CWE-399, CWE-362, CWE-310, CWE-264, CWE-200, CWE-190, CWE-189, CWE-119, CWE-94, CWE-20, CWE-19",Keras/TensorFlow,DL,RNN,BiLSTM,Binary,No,,,
,liu2023vulnerable,Solidity,,Vulnerable smart contract function locating based on Multi-Relational Nested Graph Convolutional Network,Semantic,Benchmark,N.A,N.A,Smartbugs Wild,contract file,Code,Source code,Graph,N.A,GCN,Graph embedding,"arithmetic, reentrancy and timestamp dependenc",PyTorch,DL,GNN,GCN,Binary,No,,,
,wu2023slicedlocator,,,SlicedLocator: Code vulnerability locator based on sliced dependence graph,Granularity,Hybrid,N.A,CVE,SARD,SDG,Code,Source code,Graph,N.A,"node embedding, edje embedding, adjacency matrix",Graph embedding,"CWE-190, CWE-128, CWE-121, CWE-125, CWE-122, CWE-476","Joern, PyTorch, tree-sitter",DL,Hybrid,"GNN, LSTM",Binary,No,,,
,li2023vulhunter,Solidity,,VulHunter: Hunting Vulnerable Smart Contracts at EVM Bytecode-Level via Multiple Instance Learning,Rely on expert rules,Hybrid,N.A,Etherscan,Chen et al,CFG,Code,Source code,Graph,N.A,LSTM,Token vector embedding,N.A,PyTorch,DL,RNN,LSTM,Binary,No,,,
,xu2022detecting,,,Detecting code vulnerabilities by learning from large-scale open source repositories,Semantic,Hybrid,N.A,GitHub,NVD,AST over functions,Code,Source code,Tree,N.A,Word2vec,Others,"CWE-119, CWE-399, CWE-401, CWE-415, CWE-416, CWE-20, CWE-22, CWE-129, CWE-400, CWE-476",N.A,DL,RNN,BiLSTM,Binary,No,,,
,song2023hgivul,,,HGIVul: Detecting inter-procedural vulnerabilities based on hypergraph convolution,Granularity,Benchmark,N.A,N.A,D2A,ICFG over changes,Code,Source code,Graph,N.A,graph embedding,Graph embedding,N.A,PyTorch,DL,GNN,GCN,Binary,No,,,
,hanif2022vulberta,,,VulBERTa: Simplified Source Code Pre-Training for Vulnerability Detection,Semantic,Hybrid,N.A,GitHub,Draper,functions,Code,Source code,Token,N.A,BERT Embedding,Transformer Embedding,N.A,"PyTorch, PyGithub, BPE Tokenizer, Transformers, Clang",DL,CNN,CNN,Binary,No,,,
,fan2023vdotr,,,VDoTR: Vulnerability detection based on tensor representation of comprehensive code graphs,Semantic,Hybrid,"Asterisk, FFmpeg, LibPNG, LibTiff, Pidgin, VLC Media Player",N.A,"SARD, NVD","AST, CFG, DFG, NCS",Code,Source code,Graph,N.A,graph embedding,Graph embedding,"CWE-119, CWE-120, CWE-469, CWE-476",N.A,DL,GNN,GGNN,Binary,No,,,
,gu2023binaiv,,,BinAIV: Semantic-enhanced vulnerability detection for Linux x86 binaries,Semantic,Open Source Projects,"binutils-2.40, coreutils-9.3, diffutils-3.10, findutils-4.9.0, tcpdump- 4.9.3, gmp-6.2.1, curl-7.82.0, libpcap-1.9.1, libgd-2.1.1, libarchive-3.1.2, openjpeg-2.1, openssh-7.3p1, libav-12, ffmpeg-2.8.6, libressl-2.7.0",N.A,N.A,binary,Code,Binary code,Token,N.A,BERT Embedding,Transformer Embedding,N.A,N.A,Others,Others,Similarity Measure,Binary,No,,,
,wan2023software,,,Software Vulnerability Detection via Doc2vec with path representations,Scalability,Hybrid,N.A,CVE,SARD,CPG,Code,Source code,Graph,N.A,Word2vec,Graph embedding,"CWE-78, CWE-121, CWE-122, CWE-124, CWE-126, CWE-127, CWE-134, CWE-195, CWE-20, CWE-22, CWE-78, CWE-119, CWE-125, CWE-190, CWE-254, CWE-399, CWE-400, CWE-787","Joern, PyTorch, Networkx",DL,CNN,TextCNN,Binary,No,,,
,tian2024enhancing,,,Enhancing vulnerability detection via AST decomposition and neural sub-tree encoding,Semantic,Benchmark,N.A,N.A,"SARD, D2A, VulDeePecker, Reveal, muVulDeePecker",AST,Code,Source code,Token,N.A,skip-gram,Token vector embedding,"CWE-22, CWE-73, CWE-77, CWE-119, CWE-134, CWE-176, CWE-190, CWE-191, CWE-200, CWE-252, CWE-253, CWE-271, CWE-284, CWE-319, CWE-325, CWE-327, CWE-328, CWE-362, CWE-369, CWE-377, CWE-390, CWE-391","PyTorch, GenSim",DL,Attention Mechanism,Attention Mechanism,Binary,No,,,
,pan2023fine,,,Fine-grained Commit-level Vulnerability Type Prediction by CWE Tree Structure,Vulnerability Types,Hybrid,N.A,"CVE, GitHub",NVD,Code change,Code,Source code,Token,N.A,BERT Embedding,Transformer Embedding,N.A,N.A,DL,RNN,BiLSTM,Binary,No,,,
,wen2023meta,,,Meta-Path Based Attentional Graph Learning Model for Vulnerability Detection,heterogeneous relation,Hybrid,"FFMPeg, QEMU",N.A,"Fan et al, Reveal",Code graph,Code,Source code,Graph,N.A,Graph embedding,Graph embedding,"CWE-787, CWE-79, CWE-89, CWE-416, CWE-78, CWE-20, CWE-125, CWE-22, CWE-352, CWE-434, CWE-862, CWE-476, CWE-287, CWE-190, CWE-502, CWE-77, CWE-119, CWE-798, CWE-918, CWE-306, CWE-362, CWE-269, CWE-94, CWE-863, CWE-276",PyTorch,DL,GNN,GNN,Binary,No,,,
,dong2023dekedver,,,DeKeDVer: A deep learning-based multi-type software vulnerability classification framework using vulnerability description and source code,Vulnerability Types,Benchmark,N.A,N.A,NVD,"CPG, Bug report",Hybrid,Hybrid,Hybrid,Token+Graph,"Word2vec, node embedding, edge embedding",Hybrid,"CWE-119, CWE-189, CWE-20, CWE-200, CWE-22, CWE-264, CWE-400, CWE-416, CWE-476","PyTorch, Joern",DL,GNN,"TextRCNN, RGAT",Binary,No,,,
,allamanis2021self,,,Self-supervised bug detection and repair,Training data problem,Repository,N.A,PyPI,N.A,Code graph,Code,Source code,Graph,N.A,Graph embedding,Graph embedding,N.A,PyTorch,DL,GNN,GNN,Binary,No,,,
,jain2023multi,Solidity,,Multi-Objective Approach for Detecting Vulnerabilities in Ethereum Smart Contracts,Vulnerability Types,Repository,N.A,Etherscan,N.A,binary,Code,Binary code,Token,N.A,co-occurrence matrix,Others,"CWE-190, CallDepth, TOD, TimeDep, Reentrancy, AssertFail, TxOrigin, CheckEffect, InlineAssembly, BlockTimestamp, LowlevelCalls","scikit-learn, Keras/TensorFlow",DL,Attention Mechanism,Attention Mechanism,Binary,No,,,
,chen2023smart,Solidity,,Smart contract vulnerability detection based on semantic graph and residual graph convolutional networks with edge attention,Semantic,Benchmark,N.A,N.A,Smartbugs Wild,AST,Code,Source code,Graph,Tree+Graph,"Word2vec, GCN, edge attention",Hybrid,N.A,PyTorch,DL,GNN,RGCN,Binary,No,,,
,jie2023novel,Solidity,,A novel extended multimodal AI framework towards vulnerability detection in smart contracts,General,Benchmark,N.A,N.A,SmartEmbed,"functions, CFG",Code,Source code,Graph,Token+Graph,"Word2vec, BER, graph embedding",Hybrid,N.A,"Keras/TensorFlow, GenSim, Stellargraph, PyTorch",DL,Hybrid,"BiLSTM, TextCNN",Binary,No,,,
,hussain2024vulnerability,,,Vulnerability detection in Java source code using a quantum convolutional neural network with self-attentive pooling deep sequence and graph-based hybrid feature extraction,Granularity,Hybrid,N.A,CVE,"Juliet Java 1.3, FUNDED, Vul4J","CPG, functions",Code,Source code,Graph,Token+Graph,"Node2Vec, codeBERT, GCN-RFEMLP",Hybrid,N.A,"Keras/TensorFlow, scikit-learn",DL,CNN,QCNN,Binary,Yes,,,
,zhu2023grabit,Solidity,,GraBit: A Sequential Model-Based Framework for Smart Contract Vulnerability Detection,Embedding issues,Benchmark,N.A,N.A,Smartbugs Wild,Code graph,Code,Source code,Graph,N.A,GraphCodeBERT,Transformer Embedding,reentrancy,PyTorch,DL,RNN,BiLSTM,Binary,No,,,
,zheng2021vu1spg,,,Vu1SPG: Vulnerability detection based on slice property graph representation learning,Semantic,Hybrid,"FFmpeg, QEMU",N.A,"SARD, NVD","SPG, DDG, CDG, FCDG",Code,Source code,Graph,N.A,"graph embedding, word2vec, one-hot",Hybrid,N.A,"PyTorch, DGL ",DL,GNN,RGCN,Binary,No,,,
,nguyen2024context,,,Context-based statement-level vulnerability localization,Granularity,Benchmark,N.A,N.A,Big-Vul,functions,Code,Source code,Token,N.A,"Word2Vec, GloVe, FastText, CodeBERT",Token vector embedding,N.A,N.A,DL,DNN,Representation learning,localization,Yes,,,
,wu2024ultravcs,,,UltraVCS: Ultra-Fine-Grained Variable-Based Code Slicing for Automated Vulnerability Detection,Irrelevant code fragments,Hybrid,"FFmpeg, Asterisk, LibTIFF, LibPNG",CVE,N.A,CFG over functions,Code,Source code,Graph,N.A,Word2vec,Token vector embedding,N.A,"Keras/TensorFlow, GenSim",DL,Hybrid,"RNN, GGNN",Binary,No,,,
,guo2022hyvuldect,,,HyVulDect: A hybrid semantic vulnerability mining system based on graph neural network,High false positive of static analyzers,Hybrid,"FFmpeg, Qemu, PHP, OpenSSL, Libav, Linux Kernel",CVE,SARD,CPG over programs,Code,Source code,Graph,N.A,Word2vec,Graph embedding,"CWE-404, CWE-476, CWE-119, CWE-706, CWE-400, CWE-74, CWE-704",N.A,DL,RNN,"GRU, BiLSTM",Binary,Yes,,,
,huang2024effective,Solidity,,Effective combining source code and opcode for accurate vulnerability detection of smart contracts in edge AI systems,General,Benchmark,N.A,N.A,"Smartbugs Wild, Smart Contract Dataset",files,Code,Binary code,Token,N.A,Word2vec,Token vector embedding,N.A,PyTorch,DL,RNN,‌BiLSTM,Binary,Yes,,,
,xiao2024msgvul,,,MSGVUL: Multi-semantic integration vulnerability detection based on relational graph convolutional neural networks,General,Hybrid,"FFmpeg, Qemu, PHP, OpenSSL, Libav, Linux Kernel",N.A,"NVD, SARD",CPG over files,Code,Source code,Graph,Token+Graph,"word2vec, node2vec, fasttext",Graph embedding,N.A,N.A,DL,Hybrid,"LSTM, RGCN",Binary,Yes,,,
,wang2023lcvd,,,LCVD: Loop-oriented code vulnerability detection via graph neural network,Semantic,Benchmark,N.A,N.A,"SARD, NVD",CPG over files,Code,Source code,Graph,N.A,"Word2Vec, GNN",Graph embedding,"CWE-606, CWE-834, CWE-835, CWE-190, CWE-400","PyTorch, PyTorch, Joern",DL,GNN,GNN,Binary,No,,,
,wen2023vulnerability,,,Vulnerability Detection with Graph Simplification and Enhanced Graph Representation Learning,lack of modeling large range dependencies,Hybrid,"FFMpeg, Qemu",N.A,"Reveal, Fan et al",code graph,Code,Source code,Graph,N.A,Word2vec,Graph embedding,CWE-77,Joern,DL,GNN,GCN,Binary,No,,,
,wang2023deepvd,,,DeepVD: Toward Class-Separation Features for Neural Network Vulnerability Detection,limited in the ability to distinguish between the two classes of vulnerability and benign code,Repository,N.A,"CVE, GitHub",N.A,code graph,Code,Source code,Graph,Token+Tree+Graph,"node2vec, Graph embedding",Hybrid,N.A,Joern,DL,Hybrid,"GRU, Tree-LSTM, GCN",Binary,No,,,
,wang2023binvuldet,,,BinVulDet: Detecting vulnerability in binary program via decompiled pseudo code and BiLSTM-attention,Irrelevant code fragments,Benchmark,N.A,N.A,"Juliet Test Suit, SARD","AST, PDG",Code,Binary code,Graph,N.A,Word2vec,Token vector embedding,"CWE23, CWE36, CWE78, CWE121, CWE122, CWE123, CWE124, CWE126, CWE127, CWE134, CWE190, CWE191, CWE194, CWE195, CWE196, CWE197, CWE242, CWE252, CWE253, CWE367, CWE369, CWE377, CWE390, CWE391, CWE400, CWE401, CWE404, CWE415, CWE416, CWE426, CWE427, CWE457, CWE459, CWE475, CWE510, CWE511, CWE526, CWE590, CWE605, CWE606, CWE617, CWE665, CWE666, CWE667, CWE675, CWE680, CWE685, CWE688, CWE690, CWE758, CWE761, CWE773, CWE775, CWE789, CWE832",Keras/TensorFlow,DL,RNN,BiLSTM,Binary,No,,,
,cao2021bgnn4vd,,,BGNN4VD: Constructing Bidirectional Graph Neural-Network for Vulnerability Detection,High false positive of static analyzers,Hybrid,N.A,GitHub,NVD,CCG,Code,Source code,Graph,N.A,Word2vec,Graph embedding,N.A,Keras/TensorFlow,DL,GNN,"BGNN, GNN",Binary,No,,,
,chen2023bitcn_drsn,,,BiTCN_DRSN: An effective software vulnerability detection model based on an improved temporal convolutional network,Semantic,Benchmark,N.A,N.A,VulDeePecker,functions,Code,Source code,Token,N.A,Word2vec,Token vector embedding,"CWE-119, CWE-399",Keras/TensorFlow,DL,CNN,"TCN, DRSN",Binary,No,,,
,lu2024grace,,,GRACE: Empowering LLM-based software vulnerability detection with graph structure and in-context learning,Semantic,Hybrid,"FFmpeg, Qemu",N.A,"Big-Vul, Reveal",AST,Code,Source code,Tree,Token+Tree,GPT-4,Transformer Embedding,"CWE-119, CWE-20, CWE-399, CWE-125, CWE-264, CWE-200, CWE-189, CWE-416, CWE-190, CWE-362, CWE-476, CWE-787, CWE-284, CWE-254, CWE-310",N.A,DL,Transformers,GPT-4,Binary,No,,,
,sun2023assbert,Solidity,,ASSBert: Active and semi-supervised bert for smart contract vulnerability detection,Training data problem,Benchmark,N.A,N.A,"Smartbugs Wild, SoliAudit-benchmark, SolidiFi",Gadget,Code,Source code,Graph,N.A,BERT Embedding,Transformer Embedding,"Timestemp, CallDepth, Reentrancy, TOD, Flow, Tx.origin",N.A,DL,Transformers,BERT,Binary,No,,,
,cheng2019static,,,Static Detection of Control-Flow-Related Vulnerabilities Using Graph Embedding,Semantic,Benchmark,N.A,N.A,SARD,CFG,Code,Source code,Graph,N.A,"Doc2Vec, Graph Embedding",Hybrid,"CWE-691, CWE-840, CWE-438",PyTorch,DL,GNN,GCN,Binary,No,,,
,ni2023function,,,Function-Level Vulnerability Detection Through Fusing Multi-Modal Knowledge,modality,Benchmark,N.A,N.A,Big-Vul,"AST, CFG, CDF, DDG",Code,Source code,Graph,N.A,Graph embedding,Graph embedding,"CWE-772, CWE-269, CWE-310, CWE-59, CWE-404, CWE-415, CWE-416, CWE-362, CWE-190, CWE-189, CWE-476, CWE-125, CWE-399, CWE-20, CWE-264, CWE-119",Joern,DL,GNN,"GAT, GCN",Binary,No,,,
,cai2023software,,,A software vulnerability detection method based on deep learning with complex network analysis and subgraph partition,general,Hybrid,N.A,CVE,SARD,CPG,Code,Source code,Graph,N.A,Word2vec,Token vector embedding,"CWE-78, CWE-121, CWE-122, CWE-124, CWE-126, CWE-127, CWE-134, CWE-195, CWE-20, CWE-22, CWE-78, CWE-119, CWE-125, CWE-190, CWE-254, CWE-399, CWE-400, CWE-787","PyTorch, Networkx, Joern",DL,CNN,TextCNN,Binary,No,,,
,you2023smartdt,Solidity,,SmartDT: An Effective Vulnerability Detection System of Smart Contracts Based on Deep Learning,lack of interpretation,Repository,N.A,Etherscan,N.A,file,Code,Binary code,Token,N.A  ,Word2vec,Token vector embedding,"CWE-190, CWE-191, Unchecked Call Return Value, Reentrancy, Transaction Order Dependence, Authorization thorugh tx.origin",N.A,DL,Hybrid,BiLSTM,Binary,No,,,
,yu2023pscvfinder,Solidity,,PSCVFinder: A Prompt-Tuning Based Framework for Smart Contract Vulnerability Detection,Irrelevant code fragments,Benchmark,N.A,N.A,"Smartbugs Wild,  ESC",file,Code,Source code,Token,Token,GPT-4,Transformer Embedding,"Reentrancy, Timestamp dependency",N.A,DL,Transformers,Code-T5,Binary,No,,,
,chen2024hybrid,,,Hybrid semantics-based vulnerability detection incorporating a Temporal Convolutional Network and Self-attention Mechanism,general,Benchmark,N.A,N.A,"VulDeePecker, SySeVR",Gadget,Hybrid,Hybrid,Hybrid,Token+image,Word2vec+numeric matrix,Hybrid,N.A,Keras/TensorFlow,DL,Hybrid,"CNN, TCN",Binary,No,,,
,yuan2023enhancing,,,Enhancing Deep Learning-based Vulnerability Detection by Building Behavior Graph Model,inter function modeling,Open Source Projects,"FFMpeg, QEMU, chrome, Debian",N.A,N.A,slices over functions,Code,Source code,Graph,N.A,"CodeBERT, Node2Vec, word2vec",Hybrid,N.A,"Joern, PyTorch",DL,DNN,FCN,Binary,No,,,
,ashizawa2021eth2vec,Solidity,,Eth2Vec: Learning contract-wide code representations for vulnerability detection on Ethereum smart contracts,general,Repository,N.A,Etherscan,N.A,AST,Code,Binary code,Tree,N.A,Token vector embedding,Token vector embedding,"Reentrancy, Time dependency, ERC-20 transfer, Gas consumption, implicit visibility, CWE-190, CWE-191","Kam1n0, py-solc-x",DL,Hybrid,"Similarity Measure, model",ranking,No,,,
,cai2024fine,Solidity,,Fine-grained smart contract vulnerability detection by heterogeneous code feature learning and automated dataset construction,Semantic,Repository,N.A,Etherscan,N.A,"CFG, AST",Code,Source code,Graph,N.A,GCN,Graph embedding,"CWE-190, Unchecked low-level call, ERC20 transaction order dependency, Unsafe recast, Reentrancy, Access control","PyTorch, DGL",DL,Hybrid,"GCN,GNN, Tree-LSTM",Binary,No,,,
,li2023commit,,,"Commit-Level, Neural Vulnerability Detection and Assessment",commit-level vulnerability detection and assessment at once.,Benchmark,N.A,N.A,"Big-Vul, CVAD",PDG over code change,Code,Source code,Graph,N.A,GCN,Graph embedding,N.A,N.A,DL,GNN,"GCN, FCN",Binary,No,,,
,tang2023csgvd,,,CSGVD: A deep learning approach combining sequence and graph embedding for source code vulnerability detection,Semantic,Hybrid,"QEMU, FFmpeg",N.A,codeXGLUE,CFG over programs,Code,Source code,Graph,N.A,"codeBERT, GNN, GCN",Hybrid,N.A,N.A,DL,Hybrid,"GNN, GCN, BiLSTM",Binary,No,,,
,ren2023smart,,,Smart contract vulnerability detection based on a semantic code structure and a self-designed neural network,general,Repository,N.A,"Etherscan, GitHub",N.A,XFG over files,Code,Source code,Graph,N.A,Word2vec,Token vector embedding,"CWE-190, reentrancy, delegate calls, timestamp dependency",PyTorch,DL,RNN,BiLSTM,Binary,No,,,
,guo2023reentrancy,,,Reentrancy Vulnerability Detection Based on Graph Convolutional Networks and Expert Patterns,general,Benchmark,N.A,N.A,"Ferreira et al, Qian et al, Darieux et al",CFG over files,Code,Binary code,Graph,N.A,"Word2vec, auto encoder, PCA",Hybrid,N.A,N.A,DL,GNN,"GAT, GCN",Binary,No,,,
,zhen2024gnn,,,DA-GNN: A smart contract vulnerability detection method based on Dual Attention Graph Neural Network,expert rules,Repository,N.A,Etherscan,N.A,CFG over files,Code,Binary code,Graph,N.A,Graph embedding,Graph embedding,N.A,PyTorch,DL,GNN,GAT,Binary,No,,,
,li2023smart,,,Smart Contract Vulnerability Detection Based on Automated Feature Extraction and Feature Interaction,general,Benchmark,N.A,N.A,"ESC, VSC",contract graph,Code,image,image,N.A,"GRU, one hot, VGG16",Hybrid,reentrancy,Keras/TensorFlow,DL,Hybrid,"GRU, DCN",Binary,No,,,
,zhang2023svscanner,,,SVScanner: Detecting smart contract vulnerabilities via deep semantic extraction,expert rules,Repository,N.A,"GitHub, Etherscan, CVE",N.A,AST over files,Code,Source code,Tree,N.A,Token vector embedding+Graph embedding,Hybrid,N.A,solidity-parser-antlr,DL,Hybrid,"BiLSTM, TextCNN",Binary,No,,,
1,zhou2023smart,,,Smart contracts vulnerability detection model based on adversarial multi-task learning,general,Benchmark,N.A,N.A,Huang et al.,contract files,Code,Binary code,Token,N.A,Token vector embedding+Graph embedding,Token vector embedding,"CWE-190, CWE-191, reentrancy vulnerability, unknown address vulnerability",N.A,DL,RNN,BiLSTM,Binary,No,,,
,zheng2023multitype,,,A multitype software buffer overflow vulnerability prediction method based on a software graph structure and a self-attentive graph neural network,buffer overflow,Benchmark,N.A,N.A,NIST,CPG over functions,Code,Source code,Graph,N.A,Token vector embedding+Graph embedding,Graph embedding,CWE-121/CWE-122,PyTorch,DL,Hybrid,"LSTM, GCN, GRU",Binary,No,,,
,wang2024graph,,,Graph Confident Learning for Software Vulnerability Detection,semantic,Open Source Projects,"FFmpeg, QEMU, Chrome_debian",N.A,N.A,code graph,Code,Source code,Graph,N.A,glove+Graph embedding,Graph embedding,N.A,Keras/TensorFlow,DL,Hybrid,"GCL, GRU",Binary,No,,,
,nguyen2024code,,,Code-centric learning-based just-in-time vulnerability detection,general,Repository,N.A,GitHub,N.A,CTG over code change,Code,Source code,Graph,N.A,word2vec+Graph embedding,Graph embedding,N.A,Keras/TensorFlow,DL,GNN,GNN,Binary,No,,,
1,li2023cross,,,Cross-domain vulnerability detection using graph embedding and domain adaptation,real world project,Open Source Projects,"FFmpeg, QEMU, Chrome_debian",N.A,N.A,CPG over functions,Code,Source code,Graph,N.A,word2vec+Graph embedding,Graph embedding,N.A,PyTorch,DL,Hybrid,"GGNN, GRU",Binary,No,,,
,liu2024detect,,,Detect software vulnerabilities with weight biases via graph neural networks,semantic,Open Source Projects,"FFmpeg, QEMU",N.A,N.A,AST over functions,Code,Source code,Graph,N.A,glove+Graph embedding,Graph embedding,N.A,N.A,DL,GNN,GGNN,Binary,No,,,
,nguyen2023mando,,,MANDO-HGT: Heterogeneous Graph Transformers for Smart Contract Vulnerability Detection,general,Benchmark,N.A,N.A,"Smartbugs Wild, SolidiFi","CFG, call graph",Code,Binary code,Graph,N.A,node2vec,Graph embedding,N.A,N.A,DL,GNN,GNN,Binary,No,,,
1,zhang2023cpvd,,,CPVD: Cross Project Vulnerability Detection Based on Graph Attention Network and Domain Adaptation,experts to spend a lot of time annotating.,Hybrid,N.A,CVE,"NVD, FUNDED, Devign, D2A, Reveal",CPG over functions,Code,Source code,Graph,N.A,word2vec+graph embedding,Graph embedding,N.A,"Joern, PyTorch, DGL, scikit-learn, GenSim",DL,GNN,GAT,Binary,No,,,
,hariharan2022proximal,,,Proximal Instance Aggregator networks for explainable security vulnerability detection,general,Benchmark,N.A,N.A,"SARD, NVD",AST over functions,Code,Source code,Graph,N.A,AST Path context embedding,Others,"CWE-119, CWE-399, CWE-691",PyTorch,DL,Attention Mechanism,Attention Mechanism,Binary,No,,,
,tang2022sevuldet,,,SEVulDet: A Semantics-Enhanced Learnable Vulnerability Detector,semantic,Benchmark,N.A,N.A,"SARD, NVD",Code gadget,Code,Source code,Token,N.A,word2vec,Token vector embedding,N.A,Joern,DL,CNN,CNN,Binary,No,,,
,zhang2024vulnerability,,,Vulnerability detection based on federated learning,general,Hybrid,"Chrdeb, ffmqem",GitHub,N.A,CPG over functions,Code,Source code,Graph,N.A,graph embedding,Graph embedding,N.A,"Joern, PyTorch, DGL, scikit-learn",DL,GNN,GAT,Binary,No,,,
,yuan2023optimizing,,,Optimizing smart contract vulnerability detection via multi-modality code and entropy embedding,Rely on expert rules,Repository,N.A,Etherscan,N.A,files,Code,Source code,Token,N.A,Transformer Encoder,Others,"Reentrancy, Access control, Arithmetic, Unchecked low level calls, Denial of service, Bad randomness, Front running, Time manipulation, Short addresses, Unknown",N.A,DL,Transformers,Transformer encoder,Binary,No,,,
,wartschinski2022vudenc,,,VUDENC: Vulnerability Detection with Deep Learning on a Natural Codebase for Python,Rely on expert rules,Repository,N.A,GitHub,N.A,code snippet,Code,Source code,Token,N.A,word2vec,Token vector embedding,N.A,Keras/TensorFlow,DL,RNN,LSTM,Binary,No,,,
,liu2022cpgbert,,,CPGBERT: An Effective Model for Defect Detection by Learning Program Semantics via Code Property Graph,High false positive of static analyzers,Hybrid,"Linux Kernel, QEMU, Wireshark, FFmpeg",GitHub,N.A,CPG over functions,Code,Source code,Graph,N.A,Transformer Encoder,Graph embedding,N.A,N.A,DL,Transformers,BERT,Binary,No,,,
,kong2024multi,,,A multi-type vulnerability detection framework with parallel perspective fusion and hierarchical feature enhancement,semantic,Hybrid,QEMU,N.A,"SARD, NVD",PDG,Code,Source code,Graph,N.A,word2vec+graph embedding,Graph embedding,"CWE122, CWE121, CWE78, CWE127, CWE590","Joern, PyTorch, Keras/TensorFlow",DL,Hybrid,"BGRU, HGCN",Binary,No,,,
,sun2024vdtriplet,,,VDTriplet: Vulnerability detection with graph semantics using triplet model,semantic,Hybrid,"Linux Kernel, OpenSSL, Wireshark","CVE, GitHub",NVD,"AST, PDG over functions",Code,Source code,Graph,N.A,UniXcoder+InfoGraph,Hybrid,"CWE-20, CWE-119, CWE-125, CWE-189, CWE-190, CWE-200, CWE-399, CWE-400, CWE-416, CWE-476, CWE-754, CWE-787, CWE-835","Joern, Neo4j, PyTorch",DL,CNN,TextCNN,Distance,No,,,
,sun2024gptscan,,,GPTScan: Detecting Logic Vulnerabilities in Smart Contracts by Combining GPT with Program Analysis,lack of domain-specific property description and checking.,Hybrid,N.A,Etherscan,"Web3Bugs, DeFi Hacks dataset",contract files,Code,Source code,Token,N.A,GPT-3.5_turobo,Transformer Embedding,"Approval Not Cleared, Risky First Deposit, Price Manipulation by AMM, Price Manipulation by Buying Tokens, Vote Manipulation by Flashloan, Front Running, Wrong Interest Rate Order, Wrong Checkpoint Order, Slippage, Unauthorized Transfer","ANTLR, crytic-compiler",DL,Transformers,GPT-3.5_turbo,Fine grained interpretations,Yes,,,
,cai2023combine,,,Combine sliced joint graph with graph neural networks for smart contract vulnerability detection,Rely on expert rules,Hybrid,N.A,Etherscan,"SolidiFi, HuanGai, Smartbugs Wild",JCG over files,Code,Source code,Graph,N.A,graph embedding,Graph embedding,N.A,"solc-typed-ast, Networkx, DGL",DL,GNN,GCN,Binary,No,,,
,wu2022vulcnn,,,VulCNN: An Image-inspired Scalable Vulnerability Detection System,using Image,Benchmark,N.A,N.A,"NVD, SARD",PDG,Code,image,image,N.A,Others,Others,N.A,"Joern, sent2vec, Networkx, PyTorch ",DL,CNN,CNN,Binary,No,,,
,li2019improving,,,Improving bug detection via context-based code representation learning and attention-based neural networks,multiple methods and suffer high rate of false positives,Repository,N.A,"Jira, GitHub",N.A,AST over code chage,Code,Source code,Tree,N.A,"Word2vec, node2vec, AST Path context embedding",Hybrid,N.A,Soot,DL,RNN,Attention Mechanism,Binary,No,,,
,dong2023sedsvd,,,SedSVD: Statement-level software vulnerability detection based on Relational Graph Convolutional Network with subgraph embedding,Granularity,Benchmark,N.A,N.A,"NVD, SARD",CPG over functions,Code,Source code,Graph,N.A,graph embedding,Graph embedding,N.A,PyTorch,DL,GNN,"GGNN, GCN, RGCN",Binary,No,,,
,du2024vulnerability,,,A vulnerability severity prediction method based on bimodal data and multi-task learning,semantic,Benchmark,N.A,N.A,"NVD, ExploitDB,  Big-Vul ",AST over functions,Code,Source code,Tree,N.A,GraphCodeBERT,Transformer Embedding,N.A,Keras/TensorFlow,DL,RNN,BGRU,Binary,No,,,
,xiao2024vulnerability,,,Vulnerability Detection Based on Enhanced Graph Representation Learning,missing contextual environment features and syntax structure features,Benchmark,N.A,N.A,"NVD, SARD",SRG over functions,Code,Source code,Graph,N.A,AST Path context embedding,Others,N.A,N.A,DL,GNN,GGRU,Binary,No,,,
,tao2023vulnerability,,,Vulnerability detection through cross-modal feature enhancement and fusion,"single modal-based vulnerability detection models, which cannot effectively extract cross-modal features",Hybrid,"FFmpeg, OpenSSL",N.A,SARD,"AST, PDG",Code,Source code,Graph,Token+Graph,Word2vec,Token vector embedding,"CWE-078, CWE-122, CWE-121, CWE-124, CWE-126, CWE-127, CWE-134, CWE-194, CWE-195, CWE-197, CWE-590, CWE-690","GDB, PyTorch",DL,Hybrid,"CNN, BGRU",Binary,No,,,
